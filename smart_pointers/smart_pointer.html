<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>🌟smart_pointer - Rust错题本</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../md-favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../assets/ferris/ferris.css">
        <link rel="stylesheet" href="../theme/2018-edition.css">
        <link rel="stylesheet" href="../assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="../assets/css/mdbook-admonish.css">

</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "../";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('navy')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 缘起</a></li><li class="chapter-item expanded "><a href="../rustling_exercises.html"><strong aria-hidden="true">2.</strong> Rustlings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../intro/intro.html"><strong aria-hidden="true">2.1.</strong> intro</a></li><li class="chapter-item expanded "><a href="../type_system.html"><strong aria-hidden="true">2.2.</strong> 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../primitive_types/primitive_types.html"><strong aria-hidden="true">2.2.1.</strong> primitive_types</a></li><li class="chapter-item "><a href="../collection_types.html"><strong aria-hidden="true">2.2.2.</strong> collection types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../strings/strings.html"><strong aria-hidden="true">2.2.2.1.</strong> 🌟strings</a></li><li class="chapter-item "><a href="../vecs/vecs.html"><strong aria-hidden="true">2.2.2.2.</strong> vecs: [type, n] or vec!</a></li><li class="chapter-item "><a href="../hashmaps/hashmaps.html"><strong aria-hidden="true">2.2.2.3.</strong> hashmaps</a></li><li class="chapter-item "><a href="../structs/structs.html"><strong aria-hidden="true">2.2.2.4.</strong> structs</a></li><li class="chapter-item "><a href="../enums/enums.html"><strong aria-hidden="true">2.2.2.5.</strong> enums</a></li></ol></li><li class="chapter-item expanded "><a href="../standard_library_types.html"><strong aria-hidden="true">2.2.3.</strong> standard library types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../iterators/iterators.html"><strong aria-hidden="true">2.2.3.1.</strong> iterators</a></li><li class="chapter-item expanded "><a href="../smart_pointers/smart_pointer.html" class="active"><strong aria-hidden="true">2.2.3.2.</strong> 🌟smart_pointer</a></li></ol></li><li class="chapter-item "><a href="../conversions/conversions.html"><strong aria-hidden="true">2.2.4.</strong> ✨conversions: as、from or into traits series</a></li><li class="chapter-item "><a href="../error_handling/error_handling.html"><strong aria-hidden="true">2.2.5.</strong> ⭐🌟✨error_handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../options/options.html"><strong aria-hidden="true">2.2.5.1.</strong> options</a></li></ol></li></ol></li><li class="chapter-item "><a href="../three_essentials.html"><strong aria-hidden="true">2.3.</strong> 三大支点</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../generics/generics.html"><strong aria-hidden="true">2.3.1.</strong> 一、generics</a></li><li class="chapter-item "><a href="../traits/traits.html"><strong aria-hidden="true">2.3.2.</strong> 二、traits</a></li><li class="chapter-item "><a href="../macros/macros.html"><strong aria-hidden="true">2.3.3.</strong> macros</a></li></ol></li><li class="chapter-item "><a href="../clippy/clippy.html"><strong aria-hidden="true">2.4.</strong> clippy</a></li><li class="chapter-item "><a href="../functions/functions.html"><strong aria-hidden="true">2.5.</strong> functions</a></li><li class="chapter-item "><a href="../if/if.html"><strong aria-hidden="true">2.6.</strong> if</a></li><li class="chapter-item "><a href="../ref_borrow_lifetimes/ref_borrow_lifetimes.html"><strong aria-hidden="true">2.7.</strong> ⭐️引用、借用、生命周期</a></li><li class="chapter-item "><a href="../modules/modules.html"><strong aria-hidden="true">2.8.</strong> modules: mod keyword</a></li><li class="chapter-item "><a href="../move_semantics/move_semantics.html"><strong aria-hidden="true">2.9.</strong> ✨move_semantics</a></li><li class="chapter-item "><a href="../tests/tests.html"><strong aria-hidden="true">2.10.</strong> tests</a></li><li class="chapter-item "><a href="../threads/threads.html"><strong aria-hidden="true">2.11.</strong> threads</a></li><li class="chapter-item "><a href="../variables/variables.html"><strong aria-hidden="true">2.12.</strong> variables</a></li></ol></li><li class="chapter-item expanded "><a href="../checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Rust错题本</h1>
            <h4 class="menu-bar">日不见增 月有渐进 | 唯剃真我 方有成效｜ 惊涛拍案 千层雪起 | <a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> | 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<!--ts-->
<ul>
<li><a href="#smart-pointers">Smart Pointers</a>
<ul>
<li><a href="#further-information">Further Information</a></li>
<li><a href="#rustlings">Rustlings</a>
<ul>
<li><a href="#arc">Arc</a></li>
<li><a href="#box">Box</a></li>
<li><a href="#cow-clone-on-write">Cow: Clone-On-Write</a></li>
<li><a href="#rc">Rc</a></li>
<li><a href="#memory-leak">Memory Leak</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Mar  4 10:23:18 UTC 2023 -->
<!--te-->
<p>In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.</p>
<h2 id="further-information"><a class="header" href="#further-information">Further Information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_smart_pointer.html">智能指针 - Anatomy In First Rust Programming Class 🦀</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-00-smart-pointers.html">✨Smart Pointers: Heap、Deref、Drop、Rc、RefCell、Reference Cycle - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-01-box.html">Heap: Using Box<T> to Point to Data on the Heap - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-04-rc.html">Rc<T>(Reference Counting): single-threaded scenarios, immutable references of multiple owners, the Reference Counted Smart Pointer - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch16-03-shared-state.html">Shared-State Concurrency - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow Documentation</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/standard_library_types">rustlings-solutions-5/standard_library_types at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<h2 id="rustlings"><a class="header" href="#rustlings">Rustlings</a></h2>
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<ol>
<li>In this exercise, we are given a Vec of u32 called “numbers” with values ranging
from 0 to 99 – [ 0, 1, 2, …, 98, 99 ]</li>
<li>We would like to use this set of numbers within 8 different threads simultaneously.</li>
<li>Each thread is going to get the sum of every eighth value, with an offset.</li>
</ol>
<ul>
<li>The first thread (offset 0), will sum 0, 8, 16, …</li>
<li>The second thread (offset 1), will sum 1, 9, 17, …</li>
<li>The third thread (offset 2), will sum 2, 10, 18, …</li>
<li>…</li>
<li>The eighth thread (offset 7), will sum 7, 15, 23, …</li>
</ul>
<blockquote>
<p>Because we are using threads, our values need to be <code>thread-safe</code>. Therefore,
we are using Arc. We need to make a change in each of the two TODOs.</p>
</blockquote>
<ol>
<li>Make this code compile by filling in a value for <code>shared_numbers</code> where the
first TODO comment is</li>
<li>and create an initial binding for <code>child_numbers</code> where the second TODO comment is.</li>
</ol>
<blockquote>
<p>Try not to create any copies of the <code>numbers</code> Vec!</p>
</blockquote>
<details id="admonition-arc1-using-arc-to-keep-thread-safe" class="admonition bug">
<summary class="admonition-title">
<p>arc1: Using Arc to keep <em>thread-safe</em></p>
<p><a class="admonition-anchor-link" href="#admonition-arc1-using-arc-to-keep-thread-safe"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// arc1.rs
// In this exercise, we are given a Vec of u32 called &quot;numbers&quot; with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint"></a></p>
</summary>
<div>
<ol>
<li>Make <code>shared_numbers</code> be an <code>Arc</code> from the numbers vector. </li>
<li>Then, in order
to avoid creating a copy of <code>numbers</code>, you’ll need to create <code>child_numbers</code>
inside the loop but still in the main thread.</li>
<li><code>child_numbers</code> should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.</li>
</ol>
<blockquote>
<p>This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Concurrency Chapter in the book:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch16-00-concurrency.html">Fearless Concurrency - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<details id="admonition-solution-arcnew" class="admonition success">
<summary class="admonition-title">
<p>solution: Arc::new()</p>
<p><a class="admonition-anchor-link" href="#admonition-solution-arcnew"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // filling in a value for `shared_numbers`
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = shared_numbers.clone(); // create an initial binding for `child_numbers`
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_1_box.html">Box - Anatomy In First Rust Programming Class 🦀</a></li>
</ul>
<blockquote>
<p>At compile time, Rust needs to know <code>how much space a type takes up</code>. This becomes problematic
for <code>recursive types</code>, where a value can have as part of itself another value of the same type.</p>
</blockquote>
<p>To get around the issue, we can use a <code>Box</code> - a smart pointer used to store data on the heap,
which also allows us to wrap a recursive type.</p>
<p>The recursive type we’re implementing in this exercise is the <code>cons list</code> - a data structure
frequently found in functional programming languages. Each item in a cons list contains two
elements: the value of the current item and the next item. The last item is a value called <code>Nil</code>.</p>
<ul>
<li>Step 1: use a <code>Box</code> in the enum definition to make the code compile</li>
<li>Step 2: create both empty and non-empty cons lists by replacing <code>todo!()</code></li>
</ul>
<details id="admonition-box1" class="admonition note">
<summary class="admonition-title">
<p>box1</p>
<p><a class="admonition-anchor-link" href="#admonition-box1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `todo!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!(&quot;This is an empty cons list: {:?}&quot;, create_empty_list());
    println!(
        &quot;This is a non-empty cons list: {:?}&quot;,
        create_non_empty_list()
    );
    // convert unit tests to main
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
    test_create_empty_list();
    test_create_non_empty_list();
}

pub fn create_empty_list() -&gt; List {
    todo!()
}

pub fn create_non_empty_list() -&gt; List {
    todo!()
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint-1"></a></p>
</summary>
<div>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<p>The compiler’s message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our <code>List</code> inside a <code>Box</code>. </p>
<blockquote>
<p>More details in the book here: <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-01-box.html#enabling-recursive-types-with-boxes">Heap: Using Box<T> to Point to Data on the Heap - The Rust Programming Language</a></p>
</blockquote>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<p>Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons “list builder”.
Although the current list is one of integers (i32), feel free to change the definition
and try other types!</p>
</div>
</details>
<details id="admonition-solution-boxnew" class="admonition success">
<summary class="admonition-title">
<p>solution: Box::new()</p>
<p><a class="admonition-anchor-link" href="#admonition-solution-boxnew"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

pub fn create_empty_list() -&gt; List {
    List::Nil
}

pub fn create_non_empty_list() -&gt; List {
    List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))))
}
</code></pre></pre>
</div>
</details>
<h3 id="cow-clone-on-write"><a class="header" href="#cow-clone-on-write">Cow: Clone-On-Write</a></h3>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_2_cow.html">Cow&lt;’a, B&gt; - Anatomy In First Rust Programming Class 🦀</a></li>
</ul>
<blockquote>
<p>This exercise explores the Cow, or Clone-On-Write type.</p>
</blockquote>
<ul>
<li>Cow is a clone-on-write smart pointer.</li>
<li>It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.</li>
<li>The type is designed to work with general borrowed data via the Borrow trait.</li>
</ul>
<blockquote>
<p>This exercise is meant to show you what to expect when passing data to Cow.</p>
</blockquote>
<details id="admonition-cow1" class="admonition note">
<summary class="admonition-title">
<p>cow1</p>
<p><a class="admonition-anchor-link" href="#admonition-cow1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.
//
// This exercise is meant to show you what to expect when passing data to Cow.
// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.

// I AM NOT DONE

use std::borrow::Cow;

fn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

// convert unit tests to main
fn main() {
    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // No clone occurs because `input` doesn't need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
    reference_mutation();
    reference_no_mutation();
    owned_no_mutation();
    owned_mutation();
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    #[test]
    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // No clone occurs because `input` doesn't need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint-2"></a></p>
</summary>
<div>
<p>Since the vector is already owned, the <code>Cow</code> type doesn’t need to clone it.</p>
<p>Checkout <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow in std::borrow - Rust</a> for documentation
on the <code>Cow</code> type.</p>
</div>
</details>
<details id="admonition-solution-cowborrowed_cowowned_" class="admonition success">
<summary class="admonition-title">
<p>solution: Cow::Borrowed(<em>)/Cow::Owned(</em>)</p>
<p><a class="admonition-anchor-link" href="#admonition-solution-cowborrowed_cowowned_"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.

use std::borrow::Cow;

fn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

fn main() {
    // No clone occurs because `input` doesn't need to be mutated.
    let slice = [0, 1, 2];
    let mut input = Cow::from(&amp;slice[..]);
    match abs_all(&amp;mut input) {
        Cow::Borrowed(_) =&gt; println!(&quot;I borrowed the slice!&quot;),
        _ =&gt; panic!(&quot;expected borrowed value&quot;),
    }

    // Clone occurs because `input` needs to be mutated.
    let slice = [-1, 0, 1];
    let mut input = Cow::from(&amp;slice[..]);
    match abs_all(&amp;mut input) {
        Cow::Owned(_) =&gt; println!(&quot;I modified the slice and now own it!&quot;),
        _ =&gt; panic!(&quot;expected owned value&quot;),
    }

    // No clone occurs because `input` is already owned.
    let slice = vec![-1, 0, 1];
    let mut input = Cow::from(slice);
    match abs_all(&amp;mut input) {
        Cow::Owned(_) =&gt; println!(&quot;I own this slice!&quot;),
        _ =&gt; panic!(&quot;expected borrowed value&quot;),
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="rc"><a class="header" href="#rc">Rc</a></h3>
<blockquote>
<p>In this exercise, we want to express the concept of multiple owners via the Rc<T> type.</p>
</blockquote>
<ul>
<li>This is a model of our solar system - there is a Sun type and multiple Planets.</li>
<li>The Planets take ownership of the sun, indicating that they revolve around the sun.</li>
</ul>
<blockquote>
<p>Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.</p>
</blockquote>
<details id="admonition-rc1" class="admonition note">
<summary class="admonition-title">
<p>rc1</p>
<p><a class="admonition-anchor-link" href="#admonition-rc1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// rc1.rs
// In this exercise, we want to express the concept of multiple owners via the Rc&lt;T&gt; type.
// This is a model of our solar system - there is a Sun type and multiple Planets.
// The Planets take ownership of the sun, indicating that they revolve around the sun.

// Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.

// I AM NOT DONE

use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    // TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    // TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    // TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="#admonition-hint-3"></a></p>
</summary>
<div>
<p>This is a straightforward exercise to use the Rc<T> type:</p>
<ul>
<li>Each Planet has ownership of the Sun, and uses Rc::clone() to increment the reference count of the Sun.</li>
<li>After using drop() to move the Planets out of scope individually, the reference count goes down.</li>
<li>In the end the sun only has one reference again, to itself. </li>
</ul>
<blockquote>
<p>See more at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-04-rc.html">Rc<T>(Reference Counting): single-threaded scenarios, immutable references of multiple owners, the Reference Counted Smart Pointer - The Rust Programming Language</a></p>
</blockquote>
<ul>
<li>Unfortunately Pluto is no longer considered a planet :(</li>
</ul>
</div>
</details>
<details id="admonition-solution-arcnew-1" class="admonition success">
<summary class="admonition-title">
<p>solution: Arc::new()</p>
<p><a class="admonition-anchor-link" href="#admonition-solution-arcnew-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    let saturn = Planet::Saturn(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    let uranus = Planet::Uranus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    let neptune = Planet::Neptune(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    drop(earth);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    drop(venus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    drop(mercury);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code></pre></pre>
</div>
</details>
<h3 id="memory-leak"><a class="header" href="#memory-leak">Memory Leak</a></h3>
<details id="admonition-memory_leak1" class="admonition note">
<summary class="admonition-title">
<p>memory_leak1</p>
<p><a class="admonition-anchor-link" href="#admonition-memory_leak1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

struct Node {
    value: i32,
    parent: Option&lt;Rc&lt;Node&gt;&gt;,
    children: Vec&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    fn new(value: i32) -&gt; Rc&lt;Self&gt; {
        Rc::new(Self {
            value,
            parent: None,
            children: Vec::new(),
        })
    }

    fn add_child(&amp;mut self, child: Rc&lt;Self&gt;) {
        self.children.push(child);
        child.parent = Some(Rc::clone(&amp;self));
    }
}

fn main() {
    let root = Node::new(0);
    let child1 = Node::new(1);
    let child2 = Node::new(2);
    child1.add_child(Rc::clone(&amp;child2));
    child2.add_child(Rc::clone(&amp;child1));
    root.add_child(child1);
    root.add_child(child2);
    println!(&quot;{}&quot;, root.value);
}
</code></pre></pre>
</div>
</details>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../iterators/iterators.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../conversions/conversions.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../iterators/iterators.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../conversions/conversions.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="../book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="../assets/ferris/ferris.js"></script>
    <script type="text/javascript" src="../assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="../assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="../assets/smart-anchor.js"></script>
    <script type="text/javascript" src="../assets/pagetoc/sidebar.js"></script>

</body>
</html>
