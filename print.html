<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Rust错题本</title>
        <meta name="robots" content="noindex"/>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/ferris/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('navy')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> 缘起</a></li><li class="chapter-item expanded "><a href="rustling_exercises.html"><strong aria-hidden="true">2.</strong> Rustlings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/intro.html"><strong aria-hidden="true">2.1.</strong> intro</a></li><li class="chapter-item "><a href="type_system.html"><strong aria-hidden="true">2.2.</strong> 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitive_types/primitive_types.html"><strong aria-hidden="true">2.2.1.</strong> primitive_types</a></li><li class="chapter-item "><a href="conversions/conversions.html"><strong aria-hidden="true">2.2.2.</strong> conversions</a></li><li class="chapter-item "><a href="vecs/vecs.html"><strong aria-hidden="true">2.2.3.</strong> vecs</a></li><li class="chapter-item "><a href="hashmaps/hashmaps.html"><strong aria-hidden="true">2.2.4.</strong> hashmaps</a></li><li class="chapter-item "><a href="error_handling/error_handling.html"><strong aria-hidden="true">2.2.5.</strong> error_handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="options/options.html"><strong aria-hidden="true">2.2.5.1.</strong> options</a></li></ol></li><li class="chapter-item "><a href="smart_pointers/smart_pointer.html"><strong aria-hidden="true">2.2.6.</strong> smart_pointer</a></li><li class="chapter-item "><a href="strings/strings.html"><strong aria-hidden="true">2.2.7.</strong> strings</a></li><li class="chapter-item "><a href="structs/structs.html"><strong aria-hidden="true">2.2.8.</strong> structs</a></li><li class="chapter-item "><a href="enums/enums.html"><strong aria-hidden="true">2.2.9.</strong> enums</a></li></ol></li><li class="chapter-item "><a href="three_essentials.html"><strong aria-hidden="true">2.3.</strong> 三大支点</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/generics.html"><strong aria-hidden="true">2.3.1.</strong> 一、generics</a></li><li class="chapter-item "><a href="macros/macros.html"><strong aria-hidden="true">2.3.2.</strong> macros</a></li><li class="chapter-item "><a href="traits/traits.html"><strong aria-hidden="true">2.3.3.</strong> traits</a></li></ol></li><li class="chapter-item "><a href="clippy/clippy.html"><strong aria-hidden="true">2.4.</strong> clippy</a></li><li class="chapter-item "><a href="functions/functions.html"><strong aria-hidden="true">2.5.</strong> functions</a></li><li class="chapter-item "><a href="if/if.html"><strong aria-hidden="true">2.6.</strong> if</a></li><li class="chapter-item "><a href="iterators/iterators.html"><strong aria-hidden="true">2.7.</strong> iterators</a></li><li class="chapter-item "><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html"><strong aria-hidden="true">2.8.</strong> ⭐️引用、借用、生命周期</a></li><li class="chapter-item "><a href="modules/modules.html"><strong aria-hidden="true">2.9.</strong> modules: mod keyword</a></li><li class="chapter-item "><a href="move_semantics/move_semantics.html"><strong aria-hidden="true">2.10.</strong> ✨move_semantics</a></li><li class="chapter-item "><a href="tests/tests.html"><strong aria-hidden="true">2.11.</strong> tests</a></li><li class="chapter-item "><a href="threads/threads.html"><strong aria-hidden="true">2.12.</strong> threads</a></li><li class="chapter-item "><a href="variables/variables.html"><strong aria-hidden="true">2.13.</strong> variables</a></li></ol></li><li class="chapter-item expanded "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Rust错题本</h1>
            <h4 class="menu-bar">日不见增 月有渐进 | 唯剃真我 方有成效｜ 惊涛拍案 千层雪起 | <a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> | 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="rust错题本"><a class="header" href="#rust错题本">Rust错题本</a></h1>
<h2 id="缘起"><a class="header" href="#缘起">缘起</a></h2>
<blockquote>
<p>灵感来自：<a href="https://github.com/rust-lang/rustlings">rust-lang/rustlings: Small exercises to get you used to reading and writing Rust code!</a></p>
</blockquote>
<p>余学Rust一载有余，深感其“一说就会，一写就废“的特点。在整理了几本电子书后，受到rustlings启发，觉得确实可以起一本“Rust错题本“.</p>
<h2 id="rustlings不错更需要自己整理"><a class="header" href="#rustlings不错更需要自己整理">rustlings不错，更需要自己整理</a></h2>
<p>rustlings使用起来确实很方便，其代码也值得研究，是常见的rust入门demo类型-命令行工具。但是它必须在电脑上运行，不适合随时练习，所以觉得mdbook在线运行会更方便。</p>
<h2 id="admonish-mdbook"><a class="header" href="#admonish-mdbook">admonish-mdbook</a></h2>
<p><a href="https://tommilligan.github.io/mdbook-admonish/reference.html">Reference - The mdbook-admonish book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-to-book-chapter-mapping"><a class="header" href="#exercise-to-book-chapter-mapping">Exercise to Book Chapter mapping</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Exercise</th><th>Book Chapter</th></tr></thead><tbody>
<tr><td>variables</td><td>§3.1</td></tr>
<tr><td>functions</td><td>§3.3</td></tr>
<tr><td>if</td><td>§3.5</td></tr>
<tr><td>primitive_types</td><td>§3.2, §4.3</td></tr>
<tr><td>vecs</td><td>§8.1</td></tr>
<tr><td>move_semantics</td><td>§4.1-2</td></tr>
<tr><td>structs</td><td>§5.1, §5.3</td></tr>
<tr><td>enums</td><td>§6, §18.3</td></tr>
<tr><td>strings</td><td>§8.2</td></tr>
<tr><td>modules</td><td>§7</td></tr>
<tr><td>hashmaps</td><td>§8.3</td></tr>
<tr><td>options</td><td>§10.1</td></tr>
<tr><td>error_handling</td><td>§9</td></tr>
<tr><td>generics</td><td>§10</td></tr>
<tr><td>traits</td><td>§10.2</td></tr>
<tr><td>tests</td><td>§11.1</td></tr>
<tr><td>lifetimes</td><td>§10.3</td></tr>
<tr><td>iterators</td><td>§13.2-4</td></tr>
<tr><td>threads</td><td>§16.1-3</td></tr>
<tr><td>smart_pointers</td><td>§15, §16.3</td></tr>
<tr><td>macros</td><td>§19.6</td></tr>
<tr><td>clippy</td><td>§21.4</td></tr>
<tr><td>conversions</td><td>n/a</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Rust uses the <code>print!</code> and <code>println!</code> macros to print text to the console.</p>
<h2 id="further-information"><a class="header" href="#further-information">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello.html">Hello World</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello/print.html">Formatted print</a></li>
</ul>
<h2 id="rustlings-quiz"><a class="header" href="#rustlings-quiz">Rustlings Quiz</a></h2>
<details id="admonition-quiz1" class="admonition note">
<summary class="admonition-title">
<p>quiz1</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz1.rs}}
</code></pre></pre>
</div>
</details>
<details id="admonition-quiz2" class="admonition note">
<summary class="admonition-title">
<p>quiz2</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz2.rs}}
</code></pre></pre>
</div>
</details>
<details id="admonition-quiz3" class="admonition note">
<summary class="admonition-title">
<p>quiz3</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz3.rs}}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we’ll go through the most important ones.</p>
<h2 id="further-information-1"><a class="header" href="#further-information-1">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html">Data Types</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch04-03-slices.html">The Slice Type</a></li>
</ul>
<h2 id="rustlings"><a class="header" href="#rustlings">Rustlings</a></h2>
<details id="admonition-primitive_types1" class="admonition note">
<summary class="admonition-title">
<p>primitive_types1</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types1.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&quot;Good morning!&quot;);
    }

    let // Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!(&quot;Good evening!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-primitive_types2" class="admonition note">
<summary class="admonition-title">
<p>primitive_types2</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types2.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Characters (`char`)

    // Note the _single_ quotes, these are different from the double quotes
    // you've been seeing around.
    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if my_first_initial.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }

    let // Finish this line like the example! What's your favorite character?
    // Try a letter, try a number, try a special character, try a character
    // from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if your_character.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-primitive_types3" class="admonition note">
<summary class="admonition-title">
<p>primitive_types3</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types3.rs
// Create an array with at least 100 elements in it where the ??? is.
// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let a = ???

    if a.len() &gt;= 100 {
        println!(&quot;Wow, that's a big array!&quot;);
    } else {
        println!(&quot;Meh, I eat arrays like that for breakfast.&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-primitive_types4" class="admonition note">
<summary class="admonition-title">
<p>primitive_types4</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types4.rs
// Get a slice out of Array a where the ??? is so that the test passes.
// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[test]
fn slice_out_of_array() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-primitive_types5" class="admonition note">
<summary class="admonition-title">
<p>primitive_types5</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types5.rs
// Destructure the `cat` tuple so that the println will work.
// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let cat = (&quot;Furry McFurson&quot;, 3.5);
    let /* your pattern here */ = cat;

    println!(&quot;{} is {} years old.&quot;, name, age);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-primitive_types6" class="admonition note">
<summary class="admonition-title">
<p>primitive_types6</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types6.rs
// Use a tuple index to access the second element of `numbers`.
// You can put the expression for the second element where ??? is so that the test passes.
// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // Replace below ??? with the tuple indexing syntax.
    let second = ???;

    assert_eq!(2, second,
        &quot;This is not the 2nd number in the tuple!&quot;)
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<!--ts-->
<ul>
<li><a href="conversions/conversions.html#type-conversions">Type conversions</a>
<ul>
<li><a href="conversions/conversions.html#further-information">Further information</a></li>
<li><a href="conversions/conversions.html#rustlings">Rustlings</a>
<ul>
<li><a href="conversions/conversions.html#as_ref_mut">as_ref_mut</a></li>
<li><a href="conversions/conversions.html#from_into">from_into</a></li>
<li><a href="conversions/conversions.html#from_str">from_str</a></li>
<li><a href="conversions/conversions.html#try_from_into">try_from_into</a></li>
<li><a href="conversions/conversions.html#using_as">using_as</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Feb 25 10:21:05 UTC 2023 -->
<!--te-->
<p>Rust offers a multitude of ways to convert a value of a given type into another type.</p>
<p>The simplest form of type conversion is a type cast expression. It is denoted with the binary operator <code>as</code>. For instance, <code>println!(&quot;{}&quot;, 1 + 1.0);</code> would not compile, since <code>1</code> is an integer while <code>1.0</code> is a float. However, <code>println!(&quot;{}&quot;, 1 as f32 + 1.0)</code> should compile. The
exercise <a href="conversions/using_as.rs"><code>using_as</code></a> tries to cover this.</p>
<p>Rust also offers traits that facilitate type conversions upon implementation. These traits can be found under the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>convert</code></a> module.
The traits are the following:</p>
<ul>
<li><code>From</code> and <code>Into</code> covered in <a href="conversions/from_into.rs"><code>from_into</code></a></li>
<li><code>TryFrom</code> and <code>TryInto</code> covered in <a href="conversions/try_from_into.rs"><code>try_from_into</code></a></li>
<li><code>AsRef</code> and <code>AsMut</code> covered in <a href="conversions/as_ref_mut.rs"><code>as_ref_mut</code></a></li>
</ul>
<p>Furthermore, the <code>std::str</code> module offers a trait called <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> which helps with converting strings into target types via the <code>parse</code> method on strings. If properly implemented for a given type <code>Person</code>,
then <code>let p: Person = &quot;Mark,20&quot;.parse().unwrap()</code> should both compile and run without panicking.</p>
<p>These should be the main ways <em><strong>within the standard library</strong></em> to convert data into your desired types.</p>
<h2 id="further-information-2"><a class="header" href="#further-information-2">Further information</a></h2>
<p>These are not directly covered in the book, but the standard library has a great documentation for it.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/index.html">conversions</a></li>
<li><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code> trait</a></li>
</ul>
<h2 id="rustlings-1"><a class="header" href="#rustlings-1">Rustlings</a></h2>
<h3 id="as_ref_mut"><a class="header" href="#as_ref_mut">as_ref_mut</a></h3>
<details id="admonition-as_ref_mut" class="admonition note">
<summary class="admonition-title">
<p>as_ref_mut</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-as_ref_mut"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// AsRef and AsMut allow for cheap reference-to-reference conversions.
// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html
// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.
// Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Obtain the number of bytes (not characters) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn byte_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn char_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().chars().count()
}

// Squares a number using as_mut().
// TODO: Add the appropriate trait bound.
fn num_sq&lt;T&gt;(arg: &amp;mut T) {
    // TODO: Implement the function body.
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = &quot;Café au lait&quot;;
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = &quot;Cafe au lait&quot;;
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from(&quot;Café au lait&quot;);
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from(&quot;Cafe au lait&quot;);
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mult_box() {
        let mut num: Box&lt;u32&gt; = Box::new(3);
        num_sq(&amp;mut num);
        assert_eq!(*num, 9);
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="from_into"><a class="header" href="#from_into">from_into</a></h3>
<details id="admonition-from_into" class="admonition note">
<summary class="admonition-title">
<p>from_into</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-from_into"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// The From trait is used for value-to-value conversions.
// If From is implemented correctly for a type, the Into trait should work conversely.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html
// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.

#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

// We implement the Default trait to use it as a fallback
// when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;John&quot;),
            age: 30,
        }
    }
}

// Your task is to complete this implementation
// in order for the line `let p = Person::from(&quot;Mark,20&quot;)` to compile
// Please note that you'll need to parse the age component into a `usize`
// with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The outcome of this needs to
// be handled appropriately.
//
// Steps:
// 1. If the length of the provided string is 0, then return the default of Person
// 2. Split the given string on the commas present in it
// 3. Extract the first element from the split operation and use it as the name
// 4. If the name is empty, then return the default of Person
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
// If while parsing the age, something goes wrong, then return the default of Person
// Otherwise, then return an instantiated Person object with the results

// I AM NOT DONE

impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person {
    }
}

fn main() {
    // Use the `from` function
    let p1 = Person::from(&quot;Mark,20&quot;);
    // Since From is implemented for Person, we should be able to use Into
    let p2: Person = &quot;Gerald,70&quot;.into();
    println!(&quot;{:?}&quot;, p1);
    println!(&quot;{:?}&quot;, p2);
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_default() {
        // Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, &quot;John&quot;);
        assert_eq!(dp.age, 30);
    }
    #[test]
    fn test_bad_convert() {
        // Test that John is returned when bad string is provided
        let p = Person::from(&quot;&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
    #[test]
    fn test_good_convert() {
        // Test that &quot;Mark,20&quot; works
        let p = Person::from(&quot;Mark,20&quot;);
        assert_eq!(p.name, &quot;Mark&quot;);
        assert_eq!(p.age, 20);
    }
    #[test]
    fn test_bad_age() {
        // Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age
        let p = Person::from(&quot;Mark,twenty&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from(&quot;Mark&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from(&quot;Mark,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(&quot;,1&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(&quot;,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(&quot;,one&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from(&quot;Mike,32,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from(&quot;Mike,32,man&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="from_str"><a class="header" href="#from_str">from_str</a></h3>
<details id="admonition-from_str" class="admonition note">
<summary class="admonition-title">
<p>from_str</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-from_str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// from_str.rs
// This is similar to from_into.rs, but this time we'll implement `FromStr`
// and return errors instead of falling back to a default value.
// Additionally, upon implementing FromStr, you can use the `parse` method
// on strings to generate an object of the implementor type.
// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html
// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Empty input string
    Empty,
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::&lt;usize&gt;()
    ParseInt(ParseIntError),
}

// I AM NOT DONE

// Steps:
// 1. If the length of the provided string is 0, an error should be returned
// 2. Split the given string on the commas present in it
// 3. Only 2 elements should be returned from the split, otherwise return an error
// 4. Extract the first element from the split operation and use it as the name
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
//    with something like `&quot;4&quot;.parse::&lt;usize&gt;()`
// 6. If while extracting the name and the age something goes wrong, an error should be returned
// If everything goes well, then return a Result of a Person object
//
// As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;'_ str&gt;`. This means that if you want to return a
// string error message, you can do so via just using return `Err(&quot;my error message&quot;.into())`.

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
    }
}

fn main() {
    let p = &quot;Mark,20&quot;.parse::&lt;Person&gt;().unwrap();
    println!(&quot;{:?}&quot;, p);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!(&quot;&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));
    }
    #[test]
    fn good_input() {
        let p = &quot;John,32&quot;.parse::&lt;Person&gt;();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 32);
    }
    #[test]
    fn missing_age() {
        assert!(matches!(
            &quot;John,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            &quot;John,twenty&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!(&quot;John&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(&quot;,1&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            &quot;,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            &quot;,one&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!(&quot;John,32,&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            &quot;John,32,man&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::BadLen)
        );
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="try_from_into"><a class="header" href="#try_from_into">try_from_into</a></h3>
<details id="admonition-try_from_into" class="admonition note">
<summary class="admonition-title">
<p>try_from_into</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-try_from_into"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// try_from_into.rs
// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
// Basically, this is the same as From. The main difference is that this should return a Result type
// instead of the target type itself.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html
// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.

use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// I AM NOT DONE

// Your task is to complete this implementation
// and return an Ok result of inner type Color.
// You need to create an implementation for a tuple of three integers,
// an array of three integers, and a slice of integers.
//
// Note that the implementation for tuple and array will be checked at compile time,
// but the slice implementation needs to check the slice length!
// Also note that correct RGB color values must be integers in the 0..=255 range.

// Tuple implementation
impl TryFrom&lt;(i16, i16, i16)&gt; for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Array implementation
impl TryFrom&lt;[i16; 3]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Slice implementation
impl TryFrom&lt;&amp;[i16]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(slice: &amp;[i16]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

fn main() {
    // Use the `try_from` function
    let c1 = Color::try_from((183, 65, 14));
    println!(&quot;{:?}&quot;, c1);

    // Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
    println!(&quot;{:?}&quot;, c2);

    let v = vec![183, 65, 14];
    // With slice we should use `try_from` function
    let c3 = Color::try_from(&amp;v[..]);
    println!(&quot;{:?}&quot;, c3);
    // or take slice within round brackets and use TryInto
    let c4: Result&lt;Color, _&gt; = (&amp;v[..]).try_into();
    println!(&quot;{:?}&quot;, c4);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result&lt;Color, _&gt; = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result&lt;Color, _&gt; = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result&lt;Color, _&gt; = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result&lt;Color, _&gt; = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result&lt;Color, _&gt; = Color::try_from(&amp;v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="using_as"><a class="header" href="#using_as">using_as</a></h3>
<details id="admonition-using_as" class="admonition note">
<summary class="admonition-title">
<p>using_as</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-using_as"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Type casting in Rust is done via the usage of the `as` operator.
// Please note that the `as` operator is not only used when type casting.
// It also helps with renaming imports.
//
// The goal is to make sure that the division does not fail to compile
// and returns the proper type.
// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&quot;{}&quot;, average(&amp;values));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Vectors are one of the most-used Rust data structures. In other programming
languages, they’d simply be called Arrays, but since Rust operates on a
bit of a lower level, an array in Rust is stored on the stack (meaning it
can’t grow or shrink, and the size needs to be known at compile time),
and a Vector is stored in the heap (where these restrictions do not apply).</p>
<p>Vectors are a bit of a later chapter in the book, but we think that they’re
useful enough to talk about them a bit earlier. We shall be talking about
the other useful data structure, hash maps, later.</p>
<h2 id="further-information-3"><a class="header" href="#further-information-3">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch08-01-vectors.html">Storing Lists of Values with Vectors</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a></li>
</ul>
<h2 id="rustlings-2"><a class="header" href="#rustlings-2">Rustlings</a></h2>
<details id="admonition-vecs1" class="admonition note">
<summary class="admonition-title">
<p>vecs1</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-vecs1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// vecs1.rs
// Your task is to create a `Vec` which holds the exact same elements
// as in the array `a`.
// Make me compile and pass the test!
// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) {
    let a = [10, 20, 30, 40]; // a plain array
    let v = // TODO: declare your vector here with the macro for vectors

    (a, v)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-vecs2" class="admonition note">
<summary class="admonition-title">
<p>vecs2</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-vecs2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// vecs2.rs
// A Vec of even numbers is given. Your task is to complete the loop
// so that each number in the Vec is multiplied by 2.
//
// Make me pass the test!
//
// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for i in v.iter_mut() {
        // TODO: Fill this up so that each element in the Vec `v` is
        // multiplied by 2.
        ???
    }

    // At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.iter().map(|num| {
        // TODO: Do the same thing as above - but instead of mutating the
        // Vec, you can just return the new number!
        ???
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmaps"><a class="header" href="#hashmaps">Hashmaps</a></h1>
<p>A <em>hash map</em> allows you to associate a value with a particular key.
You may also know this by the names <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><em>unordered map</em> in C++</a>,
<a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries"><em>dictionary</em> in Python</a> or an <em>associative array</em> in other languages.</p>
<p>This is the other data structure that we’ve been talking about before, when
talking about Vecs.</p>
<h2 id="further-information-4"><a class="header" href="#further-information-4">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html">Storing Keys with Associated Values in Hash Maps</a></li>
</ul>
<h2 id="rustlings-3"><a class="header" href="#rustlings-3">Rustlings</a></h2>
<details id="admonition-hashmaps1" class="admonition note">
<summary class="admonition-title">
<p>hashmaps1</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps1.rs
// A basket of fruits in the form of a hash map needs to be defined.
// The key represents the name of the fruit and the value represents
// how many of that particular fruit is in the basket. You have to put
// at least three different types of fruits (e.g apple, banana, mango)
// in the basket and the total count of all the fruits should be at
// least five.
//
// Make me compile and pass the tests!
//
// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {
    let mut basket = // TODO: declare your hash map here.

    // Two bananas are already given for you :)
    basket.insert(String::from(&quot;banana&quot;), 2);

    // TODO: Put more fruits in your basket here.

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() &gt;= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::&lt;u32&gt;() &gt;= 5);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hashmaps2" class="admonition note">
<summary class="admonition-title">
<p>hashmaps2</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps2.rs

// A basket of fruits in the form of a hash map is given. The key
// represents the name of the fruit and the value represents how many
// of that particular fruit is in the basket. You have to put *MORE
// THAN 11* fruits in the basket. Three types of fruits - Apple (4),
// Mango (2) and Lychee (5) are already given in the basket. You are
// not allowed to insert any more of these fruits!
//
// Make me pass the tests!
//
// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO: Put new fruits if not already present. Note that you
        // are not allowed to put any type of fruit that's already
        // present!
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -&gt; HashMap&lt;Fruit, u32&gt; {
        let mut basket = HashMap::&lt;Fruit, u32&gt;::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        assert_eq!(*basket.get(&amp;Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&amp;Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&amp;Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds &gt;= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count = basket.values().sum::&lt;u32&gt;();
        assert!(count &gt; 11);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hashmaps3" class="admonition note">
<summary class="admonition-title">
<p>hashmaps3</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps3.rs

// A list of scores (one per line) of a soccer match is given. Each line
// is of the form :
// &lt;team_1_name&gt;,&lt;team_2_name&gt;,&lt;team_1_goals&gt;,&lt;team_2_goals&gt;
// Example: England,France,4,2 (England scored 4 goals, France 2).

// You have to build a scores table containing the name of the team, goals
// the team scored, and goals the team conceded. One approach to build
// the scores table is to use a Hashmap. The solution is partially
// written to use a Hashmap, complete it to pass the test.

// Make me pass the tests!

// Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

// A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&gt; HashMap&lt;String, Team&gt; {
    // The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&lt;String, Team&gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&lt;&amp;str&gt; = r.split(',').collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();
        // TODO: Populate the scores table with details extracted from the
        // current line. Keep in mind that goals scored by team_1
        // will be the number of goals conceded from team_2, and similarly
        // goals scored by team_2 will be the number of goals conceded by
        // team_1.
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -&gt; String {
        let results = &quot;&quot;.to_string()
            + &quot;England,France,4,2\n&quot;
            + &quot;France,Italy,3,1\n&quot;
            + &quot;Poland,Spain,2,0\n&quot;
            + &quot;Germany,England,2,1\n&quot;;
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec&lt;&amp;String&gt; = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec![&quot;England&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;Poland&quot;, &quot;Spain&quot;]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&quot;England&quot;).unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&quot;Spain&quot;).unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to.
For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.</p>
<h2 id="further-information-5"><a class="header" href="#further-information-5">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Error Handling</a></li>
<li><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">Generics</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/result.html">Result</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html">Boxing errors</a></li>
</ul>
<h2 id="rustlings-4"><a class="header" href="#rustlings-4">Rustlings</a></h2>
<details id="admonition-errors1" class="admonition note">
<summary class="admonition-title">
<p>errors1</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors1.rs
// This function refuses to generate text to be printed on a nametag if
// you pass it an empty string. It'd be nicer if it explained what the problem
// was, instead of just sometimes returning `None`. Thankfully, Rust has a similar
// construct to `Option` that can be used to express error conditions. Let's use it!
// Execute `rustlings hint errors1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn generate_nametag_text(name: String) -&gt; Option&lt;String&gt; {
    if name.is_empty() {
        // Empty names aren't allowed.
        None
    } else {
        Some(format!(&quot;Hi! My name is {}&quot;, name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text(&quot;Beyoncé&quot;.into()),
            Ok(&quot;Hi! My name is Beyoncé&quot;.into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&quot;&quot;.into()),
            // Don't change this line
            Err(&quot;`name` was empty; it must be nonempty.&quot;.into())
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-errors2" class="admonition note">
<summary class="admonition-title">
<p>errors2</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors2.rs
// Say we're writing a game where you can buy items with tokens. All items cost
// 5 tokens, and whenever you purchase items there is a processing fee of 1
// token. A player of the game will type in how many items they want to buy,
// and the `total_cost` function will calculate the total number of tokens.
// Since the player typed in the quantity, though, we get it as a string-- and
// they might have typed anything, not just numbers!

// Right now, this function isn't handling the error case at all (and isn't
// handling the success case properly either). What we want to do is:
// if we call the `parse` function on a string that is not a number, that
// function will return a `ParseIntError`, and in that case, we want to
// immediately return that error from our function and not try to multiply
// and add.

// There are at least two ways to implement this that are both correct-- but
// one is a lot shorter!
// Execute `rustlings hint errors2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&lt;i32&gt;();

    Ok(qty * cost_per_item + processing_fee)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost(&quot;34&quot;), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost(&quot;beep boop&quot;).unwrap_err().to_string(),
            &quot;invalid digit found in string&quot;
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-errors3" class="admonition note">
<summary class="admonition-title">
<p>errors3</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors3.rs
// This is a program that is trying to use a completed version of the
// `total_cost` function from the previous exercise. It's not working though!
// Why not? What should we do to fix it?
// Execute `rustlings hint errors3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = &quot;8&quot;;

    let cost = total_cost(pretend_user_input)?;

    if cost &gt; tokens {
        println!(&quot;You can't afford that many!&quot;);
    } else {
        tokens -= cost;
        println!(&quot;You now have {} tokens.&quot;, tokens);
    }
}

pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&lt;i32&gt;()?;

    Ok(qty * cost_per_item + processing_fee)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-errors4" class="admonition note">
<summary class="admonition-title">
<p>errors4</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors4.rs
// Execute `rustlings hint errors4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        // Hmm...? Why is this only returning an Ok value?
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
</code></pre></pre>
</div>
</details>
<details id="admonition-errors5" class="admonition note">
<summary class="admonition-title">
<p>errors5</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors5.rs

// This program uses an altered version of the code from errors4.

// This exercise uses some concepts that we won't get to until later in the course, like `Box` and the
// `From` trait. It's not important to understand them in detail right now, but you can read ahead if you like.
// For now, think of the `Box&lt;dyn ...&gt;` type as an &quot;I want anything that does ???&quot; type, which, given
// Rust's usual standards for runtime safety, should strike you as somewhat lenient!

// In short, this particular use case for boxes is for when you want to own a value and you care only that it is a
// type which implements a particular trait. To do so, The Box is declared as of type Box&lt;dyn Trait&gt; where Trait is the trait
// the compiler looks for on any value used in that context. For this exercise, that context is the potential errors
// which can be returned in a Result.

// What can we use to describe both errors? In other words, is there a trait which both errors implement?

// Execute `rustlings hint errors5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::error;
use std::fmt;
use std::num::ParseIntError;

// TODO: update the return type of `main()` to make this compile.
fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {
    let pretend_user_input = &quot;42&quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&quot;output={:?}&quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

// This is required so that `CreationError` can implement `error::Error`.
impl fmt::Display for CreationError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let description = match *self {
            CreationError::Negative =&gt; &quot;number is negative&quot;,
            CreationError::Zero =&gt; &quot;number is zero&quot;,
        };
        f.write_str(description)
    }
}

impl error::Error for CreationError {}
</code></pre></pre>
</div>
</details>
<details id="admonition-errors6" class="admonition note">
<summary class="admonition-title">
<p>errors6</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors6.rs

// Using catch-all error types like `Box&lt;dyn error::Error&gt;` isn't recommended
// for library code, where callers might want to make decisions based on the
// error content, instead of printing it out or propagating it further. Here,
// we define a custom error type to make it possible for callers to decide
// what to do next when our function returns an error.

// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    // TODO: add another error conversion function here.
    // fn from_parseint...
}

fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero(&quot;not a number&quot;),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero(&quot;-555&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero(&quot;0&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero(&quot;42&quot;), Ok(x.unwrap()));
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>Type Option represents an optional value: every Option is either Some and contains a value, or None, and does not.
Option types are very common in Rust code, as they have a number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where None is returned on error</li>
<li>Optional struct fields</li>
<li>Struct fields that can be loaned or “taken”</li>
<li>Optional function arguments</li>
<li>Nullable pointers</li>
<li>Swapping things out of difficult situations</li>
</ul>
<h2 id="further-information-6"><a class="header" href="#further-information-6">Further Information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-enum-definitions">Option Enum Format</a></li>
<li><a href="https://doc.rust-lang.org/std/option/">Option Module Documentation</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option Enum Documentation</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html">if let</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html">while let</a></li>
</ul>
<h2 id="rustlings-5"><a class="header" href="#rustlings-5">Rustlings</a></h2>
<details id="admonition-options1" class="admonition note">
<summary class="admonition-title">
<p>options1</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options1.rs
// Execute `rustlings hint options1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// This function returns how much icecream there is left in the fridge.
// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them
// all, so there'll be no more left :(
fn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; {
    // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0
    // The Option output should gracefully handle cases where time_of_day &gt; 23.
    // TODO: Complete the function body - remember to return an Option!
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
    }

    #[test]
    fn raw_value() {
        // TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, 5);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-options2" class="admonition note">
<summary class="admonition-title">
<p>options2</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options2.rs
// Execute `rustlings hint options2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = &quot;rustlings&quot;;
        let optional_target = Some(target);

        // TODO: Make this an if let statement whose value is &quot;Some&quot; type
        word = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let mut range = 10;
        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();
        for i in 0..(range + 1) {
            optional_integers.push(Some(i));
        }

        // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;
        // You can stack `Option&lt;T&gt;`'s into while let and if let
        integer = optional_integers.pop() {
            assert_eq!(integer, range);
            range -= 1;
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-options3" class="admonition note">
<summary class="admonition-title">
<p>options3</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options3.rs
// Execute `rustlings hint options3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let y: Option&lt;Point&gt; = Some(Point { x: 100, y: 200 });

    match y {
        Some(p) =&gt; println!(&quot;Co-ordinates are {},{} &quot;, p.x, p.y),
        _ =&gt; println!(&quot;no match&quot;),
    }
    y; // Fix without deleting this line.
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<!--ts-->
<ul>
<li><a href="smart_pointers/smart_pointer.html#smart-pointers">Smart Pointers</a>
<ul>
<li><a href="smart_pointers/smart_pointer.html#further-information">Further Information</a></li>
<li><a href="smart_pointers/smart_pointer.html#rustlings">Rustlings</a>
<ul>
<li><a href="smart_pointers/smart_pointer.html#arc">Arc</a></li>
<li><a href="smart_pointers/smart_pointer.html#box">Box</a></li>
<li><a href="smart_pointers/smart_pointer.html#cow">Cow</a></li>
<li><a href="smart_pointers/smart_pointer.html#rc">Rc</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Feb 25 10:21:08 UTC 2023 -->
<!--te-->
<p>In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.</p>
<h2 id="further-information-7"><a class="header" href="#further-information-7">Further Information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">Smart Pointers</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-01-box.html">Using Box to Point to Data on the Heap</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-04-rc.html">Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li>
<li><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html">Shared-State Concurrency</a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow Documentation</a></li>
</ul>
<h2 id="rustlings-6"><a class="header" href="#rustlings-6">Rustlings</a></h2>
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<details id="admonition-arc1" class="admonition note">
<summary class="admonition-title">
<p>arc1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-arc1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// arc1.rs
// In this exercise, we are given a Vec of u32 called &quot;numbers&quot; with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<details id="admonition-box1" class="admonition note">
<summary class="admonition-title">
<p>box1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-box1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `todo!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!(&quot;This is an empty cons list: {:?}&quot;, create_empty_list());
    println!(
        &quot;This is a non-empty cons list: {:?}&quot;,
        create_non_empty_list()
    );
}

pub fn create_empty_list() -&gt; List {
    todo!()
}

pub fn create_non_empty_list() -&gt; List {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="cow"><a class="header" href="#cow">Cow</a></h3>
<details id="admonition-cow1" class="admonition note">
<summary class="admonition-title">
<p>cow1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-cow1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.
//
// This exercise is meant to show you what to expect when passing data to Cow.
// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.

// I AM NOT DONE

use std::borrow::Cow;

fn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    #[test]
    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // No clone occurs because `input` doesn't need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="rc"><a class="header" href="#rc">Rc</a></h3>
<details id="admonition-rc1" class="admonition note">
<summary class="admonition-title">
<p>rc1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-rc1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// rc1.rs
// In this exercise, we want to express the concept of multiple owners via the Rc&lt;T&gt; type.
// This is a model of our solar system - there is a Sun type and multiple Planets.
// The Planets take ownership of the sun, indicating that they revolve around the sun.

// Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.

// I AM NOT DONE

use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    // TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    // TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    // TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code></pre></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Rust has two string types, a string slice (<code>&amp;str</code>) and an owned string (<code>String</code>).
We’re not going to dictate when you should use which one, but we’ll show you how
to identify and create them, as well as use them.</p>
<h2 id="further-information-8"><a class="header" href="#further-information-8">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch08-02-strings.html">Strings</a></li>
</ul>
<h2 id="rustlings-7"><a class="header" href="#rustlings-7">Rustlings</a></h2>
<details id="admonition-strings1" class="admonition note">
<summary class="admonition-title">
<p>strings1</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings1.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!(&quot;My current favorite color is {}&quot;, answer);
}

fn current_favorite_color() -&gt; String {
    &quot;blue&quot;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-strings2" class="admonition note">
<summary class="admonition-title">
<p>strings2</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings2.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let word = String::from(&quot;green&quot;); // Try not changing this line :)
    if is_a_color_word(word) {
        println!(&quot;That is a color word I know!&quot;);
    } else {
        println!(&quot;That is not a color word I know.&quot;);
    }
}

fn is_a_color_word(attempt: &amp;str) -&gt; bool {
    attempt == &quot;green&quot; || attempt == &quot;blue&quot; || attempt == &quot;red&quot;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-strings3" class="admonition note">
<summary class="admonition-title">
<p>strings3</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings3.rs
// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn trim_me(input: &amp;str) -&gt; String {
    // TODO: Remove whitespace from both ends of a string!
    ???
}

fn compose_me(input: &amp;str) -&gt; String {
    // TODO: Add &quot; world!&quot; to the string! There's multiple ways to do this!
    ???
}

fn replace_me(input: &amp;str) -&gt; String {
    // TODO: Replace &quot;cars&quot; in the string with &quot;balloons&quot;!
    ???
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me(&quot;Hello!     &quot;), &quot;Hello!&quot;);
        assert_eq!(trim_me(&quot;  What's up!&quot;), &quot;What's up!&quot;);
        assert_eq!(trim_me(&quot;   Hola!  &quot;), &quot;Hola!&quot;);
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me(&quot;Hello&quot;), &quot;Hello world!&quot;);
        assert_eq!(compose_me(&quot;Goodbye&quot;), &quot;Goodbye world!&quot;);
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(replace_me(&quot;I think cars are cool&quot;), &quot;I think balloons are cool&quot;);
        assert_eq!(replace_me(&quot;I love to look at cars&quot;), &quot;I love to look at balloons&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-strings4" class="admonition note">
<summary class="admonition-title">
<p>strings4</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings4.rs

// Ok, here are a bunch of values-- some are `String`s, some are `&amp;str`s. Your
// task is to call one of these two functions on each value depending on what
// you think each value is. That is, add either `string_slice` or `string`
// before the parentheses on each line. If you're right, it will compile!
// No hints this time!

// I AM NOT DONE

fn string_slice(arg: &amp;str) {
    println!(&quot;{}&quot;, arg);
}
fn string(arg: String) {
    println!(&quot;{}&quot;, arg);
}

fn main() {
    ???(&quot;blue&quot;);
    ???(&quot;red&quot;.to_string());
    ???(String::from(&quot;hi&quot;));
    ???(&quot;rust is fun!&quot;.to_owned());
    ???(&quot;nice weather&quot;.into());
    ???(format!(&quot;Interpolation {}&quot;, &quot;Station&quot;));
    ???(&amp;String::from(&quot;abc&quot;)[0..1]);
    ???(&quot;  hello there &quot;.trim());
    ???(&quot;Happy Monday!&quot;.to_string().replace(&quot;Mon&quot;, &quot;Tues&quot;));
    ???(&quot;mY sHiFt KeY iS sTiCkY&quot;.to_lowercase());
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.</p>
<h2 id="further-information-9"><a class="header" href="#further-information-9">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">Structures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">Method Syntax</a></li>
</ul>
<h2 id="rustlings-8"><a class="header" href="#rustlings-8">Rustlings</a></h2>
<details id="admonition-structs1" class="admonition note">
<summary class="admonition-title">
<p>structs1</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs1.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct ColorClassicStruct {
    // TODO: Something goes here
}

struct ColorTupleStruct(/* TODO: Something goes here */);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: Instantiate a classic c struct!
        // let green =

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct!
        // let green =

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit-like struct!
        // let unit_like_struct =
        let message = format!(&quot;{:?}s are fun!&quot;, unit_like_struct);

        assert_eq!(message, &quot;UnitLikeStructs are fun!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-structs2" class="admonition note">
<summary class="admonition-title">
<p>structs2</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs2.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&gt; Order {
    Order {
        name: String::from(&quot;Bob&quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: Create your own order using the update syntax and template above!
        // let your_order =
        assert_eq!(your_order.name, &quot;Hacker in Rust&quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-structs3" class="admonition note">
<summary class="admonition-title">
<p>structs3</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs3.rs
// Structs contain data, but can also have logic. In this exercise we have
// defined the Package struct and we want to test some logic attached to it.
// Make the code compile and the tests pass!
// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&gt; Package {
        if weight_in_grams &lt;= 0 {
            panic!(&quot;Can not ship a weightless package.&quot;)
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&amp;self) -&gt; ??? {
        // Something goes here...
    }

    fn get_fees(&amp;self, cents_per_gram: i32) -&gt; ??? {
        // Something goes here...
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Austria&quot;);

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Russia&quot;);

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from(&quot;Canada&quot;);
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Spain&quot;);

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Rust allows you to define types called “enums” which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust’s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust’s “pattern matching” facility, which makes it easy to run different code for different values of an enumeration.</p>
<h2 id="further-information-10"><a class="header" href="#further-information-10">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Enums</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">Pattern syntax</a></li>
</ul>
<h2 id="rustlings-9"><a class="header" href="#rustlings-9">Rustlings</a></h2>
<details id="admonition-enums1" class="admonition note">
<summary class="admonition-title">
<p>enums1</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums1.rs
// No hints this time! ;)

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define a few types of messages as used below
}

fn main() {
    println!(&quot;{:?}&quot;, Message::Quit);
    println!(&quot;{:?}&quot;, Message::Echo);
    println!(&quot;{:?}&quot;, Message::Move);
    println!(&quot;{:?}&quot;, Message::ChangeColor);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-enums2" class="admonition note">
<summary class="admonition-title">
<p>enums2</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums2.rs
// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define the different variants used below
}

impl Message {
    fn call(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&quot;hello world&quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;messages {
        message.call();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-enums3" class="admonition note">
<summary class="admonition-title">
<p>enums3</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums3.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

enum Message {
    // TODO: implement the message variant types based on their usage below
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;self, s: String) {
        println!(&quot;{}&quot;, s);
    }

    fn move_position(&amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;mut self, message: Message) {
        // TODO: create a match expression to process the different message variants
        // Remember: When passing a tuple as a function argument, you'll need extra parentheses: fn function((t, u, p, l, e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&quot;hello world&quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
</code></pre></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for rather involving syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.</p>
<h2 id="further-information-11"><a class="header" href="#further-information-11">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html">Generic Data Types</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">Bounds</a></li>
</ul>
<h2 id="rustlings-10"><a class="header" href="#rustlings-10">Rustlings</a></h2>
<details id="admonition-generics1" class="admonition note">
<summary class="admonition-title">
<p>generics1</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-generics1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut shopping_list: Vec&lt;?&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;);
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/generics">rustlings-solutions-5/generics at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-hint"></a></p>
</summary>
<div>
<p>Vectors in Rust make use of generics to create dynamically sized arrays of any type.
You need to tell the compiler what type we are pushing onto this vector.</p>
</div>
</details>
<details id="admonition-solution1-str" class="admonition note">
<summary class="admonition-title">
<p>solution1: &amp;str</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-solution1-str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut shopping_list: Vec&lt;&amp;str&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-string" class="admonition note">
<summary class="admonition-title">
<p>solution2: String</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-solution2-string"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut shopping_list: Vec&lt;String&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;); // fix here
}
</code></pre></pre>
</div>
</details>
<details id="admonition-generics2" class="admonition note">
<summary class="admonition-title">
<p>generics2</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-generics2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -&gt; Self {
        Wrapper { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn store_u32_in_wrapper() {
        assert_eq!(Wrapper::new(42).value, 42);
    }

    #[test]
    fn store_str_in_wrapper() {
        assert_eq!(Wrapper::new(&quot;Foo&quot;).value, &quot;Foo&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Currently we are wrapping only values of type ‘u32’.
Maybe we could update the explicit references to this data type somehow?</p>
<p>If you are still stuck, please read:</p>
<blockquote>
<p><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-01-syntax.html#in-method-definitions">✨Generic Data Types - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rust’s macro system is very powerful, but also kind of difficult to wrap your
head around. We’re not going to teach you how to write your own fully-featured
macros. Instead, we’ll show you how to use and create them.</p>
<p>If you’d like to learn more about writing your own macros, the
<a href="https://github.com/tfpk/macrokata">macrokata</a> project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.</p>
<h2 id="further-information-12"><a class="header" href="#further-information-12">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros</a></li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></li>
</ul>
<h2 id="rustlings-11"><a class="header" href="#rustlings-11">Rustlings</a></h2>
<details id="admonition-macros1" class="admonition note">
<summary class="admonition-title">
<p>macros1</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros1.rs
// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}

fn main() {
    my_macro();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros2" class="admonition note">
<summary class="admonition-title">
<p>macros2</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros2.rs
// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros3" class="admonition note">
<summary class="admonition-title">
<p>macros3</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros3.rs
// Make me compile, without taking the macro out of the module!
// Execute `rustlings hint macros3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod macros {
    macro_rules! my_macro {
        () =&gt; {
            println!(&quot;Check out my macro!&quot;);
        };
    }
}

fn main() {
    my_macro!();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros4" class="admonition note">
<summary class="admonition-title">
<p>macros4</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros4.rs
// Execute `rustlings hint macros4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    }
    ($val:expr) =&gt; {
        println!(&quot;Look at this other macro: {}&quot;, $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait is a collection of methods.</p>
<p>Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the <code>String</code> data type implements the <code>From&lt;&amp;str&gt;</code> trait. This allows a user to write <code>String::from(&quot;hello&quot;)</code>.</p>
<p>In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.</p>
<p>Some additional common Rust traits include:</p>
<ul>
<li><code>Clone</code> (the <code>clone</code> method)</li>
<li><code>Display</code> (which allows formatted display via <code>{}</code>)</li>
<li><code>Debug</code> (which allows formatted display via <code>{:?}</code>)</li>
</ul>
<p>Because traits indicate shared behavior between data types, they are useful when writing generics.</p>
<h2 id="further-information-13"><a class="header" href="#further-information-13">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a></li>
</ul>
<h2 id="rustlings-12"><a class="header" href="#rustlings-12">Rustlings</a></h2>
<details id="admonition-traits1" class="admonition note">
<summary class="admonition-title">
<p>traits1</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits1.rs
// Time to implement some traits!
//
// Your task is to implement the trait
// `AppendBar` for the type `String`.
//
// The trait AppendBar has only one function,
// which appends &quot;Bar&quot; to any object
// implementing this trait.
// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

impl AppendBar for String {
    // TODO: Implement `AppendBar` for type `String`.
}

fn main() {
    let s = String::from(&quot;Foo&quot;);
    let s = s.append_bar();
    println!(&quot;s: {}&quot;, s);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_foo_bar() {
        assert_eq!(String::from(&quot;Foo&quot;).append_bar(), String::from(&quot;FooBar&quot;));
    }

    #[test]
    fn is_bar_bar() {
        assert_eq!(
            String::from(&quot;&quot;).append_bar().append_bar(),
            String::from(&quot;BarBar&quot;)
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-traits2" class="admonition note">
<summary class="admonition-title">
<p>traits2</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits2.rs
//
// Your task is to implement the trait
// `AppendBar` for a vector of strings.
//
// To implement this trait, consider for
// a moment what it means to 'append &quot;Bar&quot;'
// to a vector of strings.
//
// No boiler plate code this time,
// you can do this!
// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

// TODO: Implement trait `AppendBar` for a vector of strings.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_vec_pop_eq_bar() {
        let mut foo = vec![String::from(&quot;Foo&quot;)].append_bar();
        assert_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));
        assert_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-traits3" class="admonition note">
<summary class="admonition-title">
<p>traits3</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits3.rs
//
// Your task is to implement the Licensed trait for
// both structures and have them return the same
// information without writing the same function twice.
//
// Consider what you can add to the Licensed trait.
// Execute `rustlings hint traits3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;self) -&gt; String;
}

struct SomeSoftware {
    version_number: i32,
}

struct OtherSoftware {
    version_number: String,
}

impl Licensed for SomeSoftware {} // Don't edit this line
impl Licensed for OtherSoftware {} // Don't edit this line

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_licensing_info_the_same() {
        let licensing_info = String::from(&quot;Some information&quot;);
        let some_software = SomeSoftware { version_number: 1 };
        let other_software = OtherSoftware {
            version_number: &quot;v2.0.0&quot;.to_string(),
        };
        assert_eq!(some_software.licensing_info(), licensing_info);
        assert_eq!(other_software.licensing_info(), licensing_info);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-traits4" class="admonition note">
<summary class="admonition-title">
<p>traits4</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits4.rs
//
// Your task is to replace the '??' sections so the code compiles.
// Don't change any line other than the marked one.
// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;self) -&gt; String {
        &quot;some information&quot;.to_string()
    }
}

struct SomeSoftware {}

struct OtherSoftware {}

impl Licensed for SomeSoftware {}
impl Licensed for OtherSoftware {}

// YOU MAY ONLY CHANGE THE NEXT LINE
fn compare_license_types(software: ??, software_two: ??) -&gt; bool {
    software.licensing_info() == software_two.licensing_info()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compare_license_information() {
        let some_software = SomeSoftware {};
        let other_software = OtherSoftware {};

        assert!(compare_license_types(some_software, other_software));
    }

    #[test]
    fn compare_license_information_backwards() {
        let some_software = SomeSoftware {};
        let other_software = OtherSoftware {};

        assert!(compare_license_types(other_software, some_software));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-traits5" class="admonition note">
<summary class="admonition-title">
<p>traits5</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits5.rs
//
// Your task is to replace the '??' sections so the code compiles.
// Don't change any line other than the marked one.
// Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait SomeTrait {
    fn some_function(&amp;self) -&gt; bool {
        true
    }
}

pub trait OtherTrait {
    fn other_function(&amp;self) -&gt; bool {
        true
    }
}

struct SomeStruct {}
struct OtherStruct {}

impl SomeTrait for SomeStruct {}
impl OtherTrait for SomeStruct {}
impl SomeTrait for OtherStruct {}
impl OtherTrait for OtherStruct {}

// YOU MAY ONLY CHANGE THE NEXT LINE
fn some_func(item: ??) -&gt; bool {
    item.some_function() &amp;&amp; item.other_function()
}

fn main() {
    some_func(SomeStruct {});
    some_func(OtherStruct {});
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</p>
<p>If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via <code>rustup component add clippy</code>.</p>
<h2 id="further-information-14"><a class="header" href="#further-information-14">Further information</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy">GitHub Repository</a>.</li>
</ul>
<h2 id="rustlings-13"><a class="header" href="#rustlings-13">Rustlings</a></h2>
<details id="admonition-clippy1" class="admonition note">
<summary class="admonition-title">
<p>clippy1</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy1.rs
// The Clippy tool is a collection of lints to analyze your code
// so you can catch common mistakes and improve your Rust code.
//
// For these exercises the code will fail to compile when there are clippy warnings
// check clippy's suggestions from the output to solve the exercise.
// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::f32;

fn main() {
    let pi = 3.14f32;
    let radius = 5.00f32;

    let area = pi * f32::powi(radius, 2);

    println!(
        &quot;The area of a circle with radius {:.2} is {:.5}!&quot;,
        radius, area
    )
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clippy2" class="admonition note">
<summary class="admonition-title">
<p>clippy2</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy2.rs
// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!(&quot;{}&quot;, res);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clippy3" class="admonition note">
<summary class="admonition-title">
<p>clippy3</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy3.rs
// Here's a couple more easy Clippy fixes, so you can see its utility.

// I AM NOT DONE

#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option&lt;()&gt; = None;
    if my_option.is_none() {
        my_option.unwrap();
    }

    let my_arr = &amp;[
        -1, -2, -3
        -4, -5, -6
    ];
    println!(&quot;My array! Here it is: {:?}&quot;, my_arr);

    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
    println!(&quot;This Vec is empty, see? {:?}&quot;, my_empty_vec);

    let mut value_a = 45;
    let mut value_b = 66;
    // Let's swap these two!
    value_a = value_b;
    value_b = value_a;
    println!(&quot;value a: {}; value b: {}&quot;, value_a, value_b);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Here, you’ll learn how to write functions and how the Rust compiler can help you debug errors even
in more complex code.</p>
<h2 id="further-information-15"><a class="header" href="#further-information-15">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">How Functions Work</a></li>
</ul>
<h2 id="rustlings-14"><a class="header" href="#rustlings-14">Rustlings</a></h2>
<details id="admonition-functions1" class="admonition note">
<summary class="admonition-title">
<p>functions1</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions1.rs
// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions2" class="admonition note">
<summary class="admonition-title">
<p>functions2</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions2.rs
// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&quot;Ring! Call number {}&quot;, i + 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions3" class="admonition note">
<summary class="admonition-title">
<p>functions3</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions3.rs
// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&quot;Ring! Call number {}&quot;, i + 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions4" class="admonition note">
<summary class="admonition-title">
<p>functions4</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions4.rs
// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

// This store is having a sale where if the price is an even number, you get
// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.
// (Don't worry about the function bodies themselves, we're only interested
// in the signatures for now. If anything, this is a good way to peek ahead
// to future exercises!)

// I AM NOT DONE

fn main() {
    let original_price = 51;
    println!(&quot;Your sale price is {}&quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&gt; {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&gt; bool {
    num % 2 == 0
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions5" class="admonition note">
<summary class="admonition-title">
<p>functions5</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions5.rs
// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let answer = square(3);
    println!(&quot;The square of 3 is {}&quot;, answer);
}

fn square(num: i32) -&gt; i32 {
    num * num;
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">If</a></h1>
<p><code>if</code>, the most basic (but still surprisingly versatile!) type of control flow, is what you’ll learn here.</p>
<h2 id="further-information-16"><a class="header" href="#further-information-16">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions">Control Flow - if expressions</a></li>
</ul>
<h2 id="rustlings-15"><a class="header" href="#rustlings-15">Rustlings</a></h2>
<details id="admonition-if1" class="admonition note">
<summary class="admonition-title">
<p>if1</p>
<p><a class="admonition-anchor-link" href="if/if.html#admonition-if1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// if1.rs
// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&gt; i32 {
    // Complete this function to return the bigger number!
    // Do not use:
    // - another function call
    // - additional variables
}

// Don't mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-if2" class="admonition note">
<summary class="admonition-title">
<p>if2</p>
<p><a class="admonition-anchor-link" href="if/if.html#admonition-if2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// if2.rs

// Step 1: Make me compile!
// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {
    if fizzish == &quot;fizz&quot; {
        &quot;foo&quot;
    } else {
        1
    }
}

// No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&quot;fizz&quot;), &quot;foo&quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&quot;fuzz&quot;), &quot;bar&quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&quot;literally anything&quot;), &quot;baz&quot;)
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>This section will teach you about Iterators.</p>
<h2 id="further-information-17"><a class="header" href="#further-information-17">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterator</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/">Iterator documentation</a></li>
</ul>
<h2 id="rustlings-16"><a class="header" href="#rustlings-16">Rustlings</a></h2>
<details id="admonition-iterators1" class="admonition note">
<summary class="admonition-title">
<p>iterators1</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators1.rs
//
//  Make me compile by filling in the `???`s
//
// When performing operations on elements within a collection, iterators are essential.
// This module helps you get familiar with the structure of using an iterator and
// how to go through elements within an iterable collection.
//
// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main () {
    let my_fav_fruits = vec![&quot;banana&quot;, &quot;custard apple&quot;, &quot;avocado&quot;, &quot;peach&quot;, &quot;raspberry&quot;];

    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;banana&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;avocado&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;raspberry&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 4
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators2" class="admonition note">
<summary class="admonition-title">
<p>iterators2</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators2.rs
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer. Follow the steps to complete the exercise.
// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Step 1.
// Complete the `capitalize_first` function.
// &quot;hello&quot; -&gt; &quot;Hello&quot;
pub fn capitalize_first(input: &amp;str) -&gt; String {
    let mut c = input.chars();
    match c.next() {
        None =&gt; String::new(),
        Some(first) =&gt; ???,
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// [&quot;hello&quot;, &quot;world&quot;] -&gt; [&quot;Hello&quot;, &quot;World&quot;]
pub fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; {
    vec![]
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;] -&gt; &quot;Hello World&quot;
pub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first(&quot;hello&quot;), &quot;Hello&quot;);
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(&quot;&quot;), &quot;&quot;);
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec![&quot;hello&quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_vector(&amp;words), [&quot;Hello&quot;, &quot;World&quot;]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec![&quot;hello&quot;, &quot; &quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_string(&amp;words), &quot;Hello World&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators3" class="admonition note">
<summary class="admonition-title">
<p>iterators3</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators3.rs
// This is a bigger exercise than most of the others! You can do it!
// Here is your mission, should you choose to accept it:
// 1. Complete the divide function to get the first four tests to pass.
// 2. Get the remaining tests to pass by completing the result_with_list and
//    list_of_results functions.
// Execute `rustlings hint iterators3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug, PartialEq, Eq)]
pub enum DivisionError {
    NotDivisible(NotDivisibleError),
    DivideByZero,
}

#[derive(Debug, PartialEq, Eq)]
pub struct NotDivisibleError {
    dividend: i32,
    divisor: i32,
}

// Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
// Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -&gt; Result&lt;i32, DivisionError&gt; {
    todo!();
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -&gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -&gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(
            divide(81, 6),
            Err(DivisionError::NotDivisible(NotDivisibleError {
                dividend: 81,
                divisor: 6
            }))
        );
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(format!(&quot;{:?}&quot;, result_with_list()), &quot;Ok([1, 11, 1426, 3])&quot;);
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(
            format!(&quot;{:?}&quot;, list_of_results()),
            &quot;[Ok(1), Ok(11), Ok(1426), Ok(3)]&quot;
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators4" class="admonition note">
<summary class="admonition-title">
<p>iterators4</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators4.rs
// Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn factorial(num: u64) -&gt; u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_0() {
        assert_eq!(1, factorial(0));
    }

    #[test]
    fn factorial_of_1() {
        assert_eq!(1, factorial(1));
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(2, factorial(2));
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(24, factorial(4));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators5" class="admonition note">
<summary class="admonition-title">
<p>iterators5</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` or use the `hint` watch subcommand for a hint.
//
// Make the code compile and the tests pass.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {
    let mut count = 0;
    for val in map.values() {
        if val == &amp;value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {
    // map is a hashmap with String keys and Progress values.
    // map = { &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... }
    todo!();
}

fn count_collection_for(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if val == &amp;value {
                count += 1;
            }
        }
    }
    count
}

fn count_collection_iterator(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {
    // collection is a slice of hashmaps.
    // collection = [{ &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... },
    //     { &quot;variables2&quot;: Complete, ... }, ... ]
    todo!();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(3, count_iterator(&amp;map, Progress::Complete));
    }

    #[test]
    fn count_equals_for() {
        let map = get_map();
        assert_eq!(
            count_for(&amp;map, Progress::Complete),
            count_iterator(&amp;map, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(
            6,
            count_collection_iterator(&amp;collection, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        assert_eq!(
            count_collection_for(&amp;collection, Progress::Complete),
            count_collection_iterator(&amp;collection, Progress::Complete)
        );
    }

    fn get_map() -&gt; HashMap&lt;String, Progress&gt; {
        use Progress::*;

        let mut map = HashMap::new();
        map.insert(String::from(&quot;variables1&quot;), Complete);
        map.insert(String::from(&quot;functions1&quot;), Complete);
        map.insert(String::from(&quot;hashmap1&quot;), Complete);
        map.insert(String::from(&quot;arc1&quot;), Some);
        map.insert(String::from(&quot;as_ref_mut&quot;), None);
        map.insert(String::from(&quot;from_str&quot;), None);

        map
    }

    fn get_vec_map() -&gt; Vec&lt;HashMap&lt;String, Progress&gt;&gt; {
        use Progress::*;

        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from(&quot;variables2&quot;), Complete);
        other.insert(String::from(&quot;functions2&quot;), Complete);
        other.insert(String::from(&quot;if1&quot;), Complete);
        other.insert(String::from(&quot;from_into&quot;), None);
        other.insert(String::from(&quot;try_from_into&quot;), None);

        vec![map, other]
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<!--ts-->
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#lifetimes">Lifetimes</a>
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#further-information">Further information</a></li>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#rustlings">Rustlings</a>
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#expected-named-lifetime-parameter">expected named lifetime parameter</a></li>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#borrowed-value-does-not-live-long-enough">borrowed value does not live long enough</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Feb 25 10:21:07 UTC 2023 -->
<!--te-->
<p>Lifetimes tell the compiler how to check:</p>
<blockquote>
<p>whether <code>references</code> live long enough to be valid in any given situation.</p>
</blockquote>
<p>For example lifetimes say “make sure parameter ‘a’ lives as long as parameter ‘b’ so that the return value is valid”.</p>
<blockquote>
<p>They are only necessary on borrows, i.e. references</p>
</blockquote>
<ul>
<li>Since copied parameters or moves are owned in their scope and cannot
be referenced outside.</li>
<li>Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid.</li>
<li>Lifetimes are restrictive of their callers.</li>
</ul>
<h2 id="further-information-18"><a class="header" href="#further-information-18">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Validating References with Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html">Lifetimes (in Rust By Example)</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/scope/lifetime.html">Lifetimes - The Rust Programming Language</a></li>
</ul>
<h2 id="rustlings-17"><a class="header" href="#rustlings-17">Rustlings</a></h2>
<h3 id="expected-named-lifetime-parameter"><a class="header" href="#expected-named-lifetime-parameter">expected named lifetime parameter</a></h3>
<details id="admonition-function" class="admonition bug">
<summary class="admonition-title">
<p>function</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-function"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes1.rs
//
// The Rust compiler needs to know how to check whether supplied references are
// valid, so that it can let the programmer know if a reference is at risk
// of going out of scope before it is used. Remember, references are borrows
// and do not own their own data. What if their owner goes out of scope?
//
// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is '{}'&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint"></a></p>
</summary>
<div>
<p>Let the compiler guide you. Also take a look at <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-03-lifetime-syntax.html">the book</a> if you need help:</p>
</div>
</details>
<details id="admonition-struct" class="admonition bug">
<summary class="admonition-title">
<p>struct</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-struct"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes3.rs
//
// Lifetimes are also needed when structs hold references.
//
// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Book {
    author: &amp;str,
    title: &amp;str,
}

fn main() {
    let name = String::from(&quot;Jill Smith&quot;);
    let title = String::from(&quot;Fish Flying&quot;);
    let book = Book { author: &amp;name, title: &amp;title };

    println!(&quot;{} by {}&quot;, book.title, book.author);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>If you use a lifetime annotation in a struct’s fields, where else does it need to be added?</p>
</div>
</details>
<h3 id="borrowed-value-does-not-live-long-enough"><a class="header" href="#borrowed-value-does-not-live-long-enough">borrowed value does not live long enough</a></h3>
<details id="admonition-lifetimes2" class="admonition bug">
<summary class="admonition-title">
<p>lifetimes2</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-lifetimes2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes2.rs
//
// So if the compiler is just validating the references passed
// to the annotated parameters and the return type, what do
// we need to change?
//
// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is '{}'&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-将块看作生命周期隐式声明" class="admonition tip">
<summary class="admonition-title">
<p>Hint: 将块看作生命周期隐式声明</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-将块看作生命周期隐式声明"></a></p>
</summary>
<div>
<p>Remember that the generic lifetime ’a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.
You can take at least two paths to achieve the desired result while keeping the inner block:</p>
<ol>
<li>Move the string2 declaration to make it live as long as string1 (how is result declared?)</li>
<li>Move println! into the inner block</li>
</ol>
</div>
</details>
<details id="admonition-qa" class="admonition info">
<summary class="admonition-title">
<p>Q&amp;A</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-qa"></a></p>
</summary>
<div>
<h2 id="q-为什么不能改成"><a class="header" href="#q-为什么不能改成">Q: 为什么不能改成</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a:'b, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'b str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A: 因为可能返回’a x, 也可能返回’b y. 这里主要问题在于返回的引用有两种生命周期。</p>
</blockquote>
</div>
</details>
<details id="admonition-lifetimes4" class="admonition bug">
<summary class="admonition-title">
<p>lifetimes4</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-lifetimes4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">extern crate regex; // just for running in rust playground
use regex::Regex;

fn get_publish_date(title: String) -&gt; String{
    let date_re = Regex::new(r&quot;(\d{4}-\d{2}-\d{2})&quot;).unwrap();
    // let publish_date = date_re.captures(title.as_str()).unwrap().get(1).unwrap().as_str();
    // ----------------------------------------------------^^^^^^ here to match.
    let publish_date = match date_re.captures(title.as_str()) {
        Some(captured) =&gt; captured.get(1).unwrap().as_str(), // 这里unwrap()之后只有as_str()方法, 没有to_string()
        // None =&gt; format!(&quot;Unable to extract date from {}&quot;, title).as_str() // temporary value is freed at the end of this statement
        // None =&gt; &quot;Unable to extract date from {title}&quot; // str is equal to &amp;'static str ?
        None =&gt; {
            let temp = format!(&quot;Unable to extract date from {}&quot;, title);
            temp.as_str()
        }
    };
    publish_date.to_string()
}

fn main() {
    let title = &quot;【Rust Daily】2023-01-21&quot;; // &amp;str
    let publish_date = get_publish_date(title);
    println!(&quot;Title: {}\nPublish_data: {}\n&quot;, title, publish_date);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-函数返回引用才会考虑live-long-enough" class="admonition tip">
<summary class="admonition-title">
<p>Hint: 函数返回引用才会考虑live long enough</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-函数返回引用才会考虑live-long-enough"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">extern crate regex; // just for running in rust playground
use regex::Regex;

fn get_publish_date(title: &amp;str) -&gt; String{
    let date_re = Regex::new(r&quot;(\d{4}-\d{2}-\d{2})&quot;).unwrap();
    // let publish_date = date_re.captures(title.as_str()).unwrap().get(1).unwrap().as_str();
    // ----------------------------------------------------^^^^^^ here to match.
    let publish_date = match date_re.captures(title) {
        Some(captured) =&gt; captured.get(1).unwrap().as_str().to_string(), // 这里unwrap()之后只有as_str()方法, 没有to_string()
        // None =&gt; format!(&quot;Unable to extract date from {}&quot;, title).as_str() // temporary value is freed at the end of this statement
        // None =&gt; &quot;Unable to extract date from {title}&quot; // str is equal to &amp;'static str ?
        None =&gt; format!(&quot;Unable to extract date from {}&quot;, title)
    };
    publish_date
}

fn main() {
    let title = &quot;【Rust Daily】2023-01-21&quot;;
    let publish_date = get_publish_date(title);
    println!(&quot;Title: {}\nPublish_data: {}\n&quot;, title, publish_date);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>In this section we’ll give you an introduction to Rust’s module system.</p>
<h2 id="further-information-19"><a class="header" href="#further-information-19">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">The Module System</a></li>
</ul>
<h2 id="rustlings-18"><a class="header" href="#rustlings-18">Rustlings</a></h2>
<details id="admonition-modules1-pub" class="admonition note">
<summary class="admonition-title">
<p>modules1: pub</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules1-pub"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules1.rs
// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod sausage_factory {
    // Don't let anybody outside of this module see this!
    fn get_secret_recipe() -&gt; String {
        String::from(&quot;Ginger&quot;)
    }

    fn make_sausage() {
        get_secret_recipe();
        println!(&quot;sausage!&quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint"></a></p>
</summary>
<div>
<blockquote>
<p>add <code>pub</code>
Everything is private in Rust by default– but there’s a keyword we can use
to make something public! The compiler error should point to the thing that
needs to be public.</p>
</blockquote>
</div>
</details>
<details id="admonition-modules2-use-selfxxx-as-bbb" class="admonition note">
<summary class="admonition-title">
<p>modules2: use self::xxx as bbb</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules2-use-selfxxx-as-bbb"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules2.rs
// You can bring module paths into scopes and provide new names for them with the
// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.
// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod delicious_snacks {
    // TODO: Fix these use statements
    use self::fruits::PEAR as ???
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &amp;'static str = &quot;Pear&quot;;
        pub const APPLE: &amp;'static str = &quot;Apple&quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;'static str = &quot;Cucumber&quot;;
        pub const CARROT: &amp;'static str = &quot;Carrot&quot;;
    }
}

fn main() {
    println!(
        &quot;favorite snacks: {} and {}&quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>The delicious_snacks module is trying to present an external interface that is
different than its internal structure (the <code>fruits</code> and <code>veggies</code> modules and
associated constants). Complete the <code>use</code> statements to fit the uses in main and
find the one keyword missing for both constants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie;
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-modules3" class="admonition note">
<summary class="admonition-title">
<p>modules3</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules3.rs
// You can use the 'use' keyword to bring module paths from modules from anywhere
// and especially from the Rust standard library into your scope.
// Bring SystemTime and UNIX_EPOCH
// from the std::time module. Bonus style points if you can do it with one line!
// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// TODO: Complete this use statement
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&gt; println!(&quot;1970-01-01 00:00:00 UTC was {} seconds ago!&quot;, n.as_secs()),
        Err(_) =&gt; panic!(&quot;SystemTime before UNIX EPOCH!&quot;),
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint-2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{SystemTime, UNIX_EPOCH};
<span class="boring">}
</span></code></pre></pre>
<p>UNIX_EPOCH and SystemTime are declared in the std::time module. Add a use statement
for these two to bring them into scope. You can use nested paths or the glob
operator to bring these two in using only one line.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<!--ts-->
<ul>
<li><a href="move_semantics/move_semantics.html#move-semantics">Move Semantics</a>
<ul>
<li><a href="move_semantics/move_semantics.html#further-information">Further information</a></li>
<li><a href="move_semantics/move_semantics.html#rustlings">Rustlings</a>
<ul>
<li><a href="move_semantics/move_semantics.html#%E5%80%9F%E7%94%A8">借用</a></li>
<li><a href="move_semantics/move_semantics.html#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">可变借用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Feb 25 10:21:07 UTC 2023 -->
<!--te-->
<p>These exercises are adapted from <a href="https://github.com/pnkfelix">pnkfelix</a>’s <a href="https://pnkfelix.github.io/rust-examples-icfp2014/">Rust Tutorial</a> – Thank you Felix!!!</p>
<h2 id="further-information-20"><a class="header" href="#further-information-20">Further information</a></h2>
<p>For this section, the book links are especially important.</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">Reference and borrowing</a></li>
</ul>
<h2 id="rustlings-19"><a class="header" href="#rustlings-19">Rustlings</a></h2>
<h3 id="借用"><a class="header" href="#借用">借用</a></h3>
<details id="admonition-move_semantics1" class="admonition note">
<summary class="admonition-title">
<p>move_semantics1</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics1.rs
// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    // let vec1 = fill_vec(&amp;vec0);
    // vec0.push(24); // Try accessing `vec0` after having called `fill_vec()`. See what happens!

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint"></a></p>
</summary>
<div>
<p>So you’ve got the “cannot borrow immutable local variable <code>vec1</code> as mutable” error on line 13,
right? The fix for this is going to be adding one keyword, and the addition is NOT on line 13
where the error is.</p>
<p>Also: Try accessing <code>vec0</code> after having called <code>fill_vec()</code>. See what happens!</p>
</div>
</details>
<h3 id="可变借用"><a class="header" href="#可变借用">可变借用</a></h3>
<details id="admonition-move_semantics2" class="admonition note">
<summary class="admonition-title">
<p>move_semantics2</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics2.rs
// Make me compile without changing line 13 or moving line 10!
// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    // Do not change the following line!
    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec0&quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>So, <code>vec0</code> is passed into the <code>fill_vec</code> function as an argument. In Rust,
when an argument is passed to a function and it’s not explicitly returned,
you can’t use the original variable anymore. We call this “moving” a variable.
Variables that are moved into a function (or block scope) and aren’t explicitly
returned get “dropped” at the end of that function. This is also what happens here.
There’s a few ways to fix this, try them all if you want:</p>
<ol>
<li>Make another, separate version of the data that’s in <code>vec0</code> and pass that
to <code>fill_vec</code> instead.</li>
<li>Make <code>fill_vec</code> borrow its argument instead of taking ownership of it,
and then copy the data within the function in order to return an owned
<code>Vec&lt;i32&gt;</code></li>
<li>Make <code>fill_vec</code> <em>mutably</em> borrow a reference to its argument (which will need to be
mutable), modify it directly, then not return anything. Then you can get rid
of <code>vec1</code> entirely – note that this will change what gets printed by the
first <code>println!</code></li>
</ol>
</div>
</details>
<details id="admonition-move_semantics3" class="admonition note">
<summary class="admonition-title">
<p>move_semantics3</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics3.rs
// Make me compile without adding new lines-- just changing existing lines!
// (no lines with multiple semicolons necessary!)
// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>The difference between this one and the previous ones is that the first line
of <code>fn fill_vec</code> that had <code>let mut vec = vec;</code> is no longer there. You can,
instead of adding that line back, add <code>mut</code> in one place that will change
an existing binding to be a mutable binding instead of an immutable one :)</p>
</div>
</details>
<details id="admonition-move_semantics4" class="admonition note">
<summary class="admonition-title">
<p>move_semantics4</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics4.rs
// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,
// the Vector gets created in the function itself and passed back to the main
// function.
// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

// `fill_vec()` no longer takes `vec: Vec&lt;i32&gt;` as argument
fn fill_vec() -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-3"></a></p>
</summary>
<div>
<p>Stop reading whenever you feel like you have enough direction :) Or try
doing one step and then fixing the compiler errors that result!
So the end goal is to:</p>
<ul>
<li>get rid of the first line in main that creates the new vector</li>
<li>so then <code>vec0</code> doesn’t exist, so we can’t pass it to <code>fill_vec</code></li>
<li>we don’t want to pass anything to <code>fill_vec</code>, so its signature should
reflect that it does not take any arguments</li>
<li>since we’re not creating a new vec in <code>main</code> anymore, we need to create
a new vec in <code>fill_vec</code>, similarly to the way we did in <code>main</code></li>
</ul>
</div>
</details>
<details id="admonition-move_semantics5" class="admonition note">
<summary class="admonition-title">
<p>move_semantics5</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics5.rs
// Make me compile only by reordering the lines in `main()`, but without
// adding, changing or removing any of them.
// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &amp;mut x;
    let z = &amp;mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-4" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-4"></a></p>
</summary>
<div>
<p>Carefully reason about the range in which each mutable reference is in
scope. Does it help to update the value of referent (x) immediately after
the mutable reference is taken? Read more about ‘Mutable References’:</p>
<blockquote>
<p><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch04-02-references-and-borrowing.html#mutable-references">References and Borrowing &gt; Mutable References - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<details id="admonition-move_semantics6" class="admonition note">
<summary class="admonition-title">
<p>move_semantics6</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics6.rs
// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.
// You can't change anything except adding or removing references.

// I AM NOT DONE

fn main() {
    let data = &quot;Rust is great!&quot;.to_string();

    get_char(data);

    string_uppercase(&amp;data);
}

// Should not take ownership
fn get_char(data: String) -&gt; char {
    data.chars().last().unwrap()
}

// Should take ownership
fn string_uppercase(mut data: &amp;String) {
    data = &amp;data.to_uppercase();

    println!(&quot;{}&quot;, data);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-5" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-5"></a></p>
</summary>
<div>
<p>To find the answer, you can consult the book section <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch04-02-references-and-borrowing.html#references-and-borrowing">“References and Borrowing”</a></p>
<ol>
<li>
<p>The first problem is that <code>get_char</code> is taking ownership of the string.
So <code>data</code> is moved and can’t be used for <code>string_uppercase</code>
<code>data</code> is moved to <code>get_char</code> first, meaning that <code>string_uppercase</code> cannot manipulate the data.
Once you’ve fixed that, <code>string_uppercase</code>’s function signature will also need to be adjusted.
Can you figure out how?</p>
</li>
<li>
<p>Another hint: it has to do with the <code>&amp;</code> character.</p>
</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Going out of order from the book to cover tests – many of the following exercises will ask you to make tests pass!</p>
<h2 id="further-information-21"><a class="header" href="#further-information-21">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">Writing Tests</a></li>
</ul>
<h2 id="rustlings-20"><a class="header" href="#rustlings-20">Rustlings</a></h2>
<details id="admonition-tests1" class="admonition note">
<summary class="admonition-title">
<p>tests1</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests1.rs
// Tests are important to ensure that your code does what you think it should do.
// Tests can be run on this file with the following command:
// rustlings run tests1

// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert() {
        assert!();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-tests2" class="admonition note">
<summary class="admonition-title">
<p>tests2</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests2.rs
// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert_eq() {
        assert_eq!();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-tests3" class="admonition note">
<summary class="admonition-title">
<p>tests3</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests3.rs
// This test isn't testing our function -- make it do that in such a way that
// the test passes. Then write a second test that tests whether we get the result
// we expect to get when we call `is_even(5)`.
// Execute `rustlings hint tests3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn is_even(num: i32) -&gt; bool {
    num % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_true_when_even() {
        assert!();
    }

    #[test]
    fn is_false_when_odd() {
        assert!();
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>In most current operating systems, an executed program’s code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.</p>
<h2 id="further-information-22"><a class="header" href="#further-information-22">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html">Dining Philosophers example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch16-01-threads.html">Using Threads to Run Code Simultaneously</a></li>
</ul>
<h2 id="rustlings-21"><a class="header" href="#rustlings-21">Rustlings</a></h2>
<details id="admonition-threads1" class="admonition note">
<summary class="admonition-title">
<p>threads1</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads1.rs
// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.

// This program spawns multiple threads that each run for at least 250ms,
// and each thread returns how much time they took to complete.
// The program should wait until all the spawned threads have finished and
// should collect their return values into a vector.

// I AM NOT DONE

use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        handles.push(thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!(&quot;thread {} is complete&quot;, i);
            start.elapsed().as_millis()
        }));
    }

    let mut results: Vec&lt;u128&gt; = vec![];
    for handle in handles {
        // TODO: a struct is returned from thread::spawn, can you use it?
    }

    if results.len() != 10 {
        panic!(&quot;Oh no! All the spawned threads did not finish!&quot;);
    }
    
    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!(&quot;thread {} took {}ms&quot;, i, result);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-threads2" class="admonition note">
<summary class="admonition-title">
<p>threads2</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads2.rs
// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.
// Building on the last exercise, we want all of the threads to complete their work but this time
// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed

// I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            // TODO: You must take an action before you update a shared value
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything
        // interesting in the output? Do you have to 'join' on all the handles?
        println!(&quot;jobs completed {}&quot;, ???);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-threads3" class="admonition note">
<summary class="admonition-title">
<p>threads3</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads3.rs
// Execute `rustlings hint threads3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::sync::mpsc;
use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct Queue {
    length: u32,
    first_half: Vec&lt;u32&gt;,
    second_half: Vec&lt;u32&gt;,
}

impl Queue {
    fn new() -&gt; Self {
        Queue {
            length: 10,
            first_half: vec![1, 2, 3, 4, 5],
            second_half: vec![6, 7, 8, 9, 10],
        }
    }
}

fn send_tx(q: Queue, tx: mpsc::Sender&lt;u32&gt;) -&gt; () {
    let qc = Arc::new(q);
    let qc1 = Arc::clone(&amp;qc);
    let qc2 = Arc::clone(&amp;qc);

    thread::spawn(move || {
        for val in &amp;qc1.first_half {
            println!(&quot;sending {:?}&quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        for val in &amp;qc2.second_half {
            println!(&quot;sending {:?}&quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let queue = Queue::new();
    let queue_length = queue.length;

    send_tx(queue, tx);

    let mut total_received: u32 = 0;
    for received in rx {
        println!(&quot;Got: {}&quot;, received);
        total_received += 1;
    }

    println!(&quot;total numbers received: {}&quot;, total_received);
    assert_eq!(total_received, queue_length)
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can’t change that value.
You can make them mutable by adding mut in front of the variable name.</p>
<h2 id="further-information-23"><a class="header" href="#further-information-23">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">Variables and Mutability</a></li>
</ul>
<h2 id="rustlings-22"><a class="header" href="#rustlings-22">Rustlings</a></h2>
<details id="admonition-variables1" class="admonition note">
<summary class="admonition-title">
<p>variables1</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables1.rs
// Make me compile!
// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    x = 5;
    println!(&quot;x has the value {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables2" class="admonition note">
<summary class="admonition-title">
<p>variables2</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables2.rs
// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x;
    if x == 10 {
        println!(&quot;x is ten!&quot;);
    } else {
        println!(&quot;x is not ten!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables3" class="admonition note">
<summary class="admonition-title">
<p>variables3</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables3.rs
// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x: i32;
    println!(&quot;Number {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables4" class="admonition note">
<summary class="admonition-title">
<p>variables4</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables4.rs
// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x = 3;
    println!(&quot;Number {}&quot;, x);
    x = 5; // don't change this line
    println!(&quot;Number {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables5" class="admonition note">
<summary class="admonition-title">
<p>variables5</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables5.rs
// Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let number = &quot;T-H-R-E-E&quot;; // don't change this line
    println!(&quot;Spell a Number : {}&quot;, number);
    number = 3; // don't rename this variable
    println!(&quot;Number plus two is : {}&quot;, number + 2);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables6" class="admonition note">
<summary class="admonition-title">
<p>variables6</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables6.rs
// Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

const NUMBER = 3;
fn main() {
    println!(&quot;Number {}&quot;, NUMBER);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->


                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">

    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/ferris/ferris.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

        <script type="text/javascript">
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>
</body>
</html>
