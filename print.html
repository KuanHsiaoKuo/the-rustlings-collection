<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Rust错题本</title>
        <meta name="robots" content="noindex"/>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="md-favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/ferris/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="assets/pagetoc/pagetoc_style.css">
        <link rel="stylesheet" href="assets/css/mdbook-admonish.css">

</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('navy')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> 缘起</a></li><li class="chapter-item expanded "><a href="rustling_exercises.html"><strong aria-hidden="true">2.</strong> Rustlings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/intro.html"><strong aria-hidden="true">2.1.</strong> intro</a></li><li class="chapter-item "><a href="type_system.html"><strong aria-hidden="true">2.2.</strong> 类型系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitive_types/primitive_types.html"><strong aria-hidden="true">2.2.1.</strong> primitive_types</a></li><li class="chapter-item "><a href="collection_types.html"><strong aria-hidden="true">2.2.2.</strong> collection types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="strings/strings.html"><strong aria-hidden="true">2.2.2.1.</strong> 🌟strings</a></li><li class="chapter-item "><a href="vecs/vecs.html"><strong aria-hidden="true">2.2.2.2.</strong> vecs: [type, n] or vec!</a></li><li class="chapter-item "><a href="hashmaps/hashmaps.html"><strong aria-hidden="true">2.2.2.3.</strong> hashmaps</a></li><li class="chapter-item "><a href="structs/structs.html"><strong aria-hidden="true">2.2.2.4.</strong> structs</a></li><li class="chapter-item "><a href="enums/enums.html"><strong aria-hidden="true">2.2.2.5.</strong> enums</a></li></ol></li><li class="chapter-item "><a href="standard_library_types.html"><strong aria-hidden="true">2.2.3.</strong> standard library types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/iterators.html"><strong aria-hidden="true">2.2.3.1.</strong> iterators</a></li><li class="chapter-item "><a href="smart_pointers/smart_pointer.html"><strong aria-hidden="true">2.2.3.2.</strong> 🌟smart_pointer</a></li></ol></li><li class="chapter-item "><a href="conversions/conversions.html"><strong aria-hidden="true">2.2.4.</strong> ✨conversions: as、from or into traits series</a></li><li class="chapter-item "><a href="error_handling/error_handling.html"><strong aria-hidden="true">2.2.5.</strong> ⭐🌟✨error_handling: Result&lt;T, E&gt; or panic!</a></li><li class="chapter-item "><a href="options/options.html"><strong aria-hidden="true">2.2.6.</strong> Option</a></li></ol></li><li class="chapter-item "><a href="three_essentials.html"><strong aria-hidden="true">2.3.</strong> 三大支点</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/generics.html"><strong aria-hidden="true">2.3.1.</strong> 一、generics</a></li><li class="chapter-item "><a href="traits/traits.html"><strong aria-hidden="true">2.3.2.</strong> 二、traits</a></li><li class="chapter-item "><a href="macros/macros.html"><strong aria-hidden="true">2.3.3.</strong> macros</a></li></ol></li><li class="chapter-item "><a href="clippy/clippy.html"><strong aria-hidden="true">2.4.</strong> clippy</a></li><li class="chapter-item "><a href="functions/functions.html"><strong aria-hidden="true">2.5.</strong> functions</a></li><li class="chapter-item "><a href="if/if.html"><strong aria-hidden="true">2.6.</strong> if</a></li><li class="chapter-item "><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html"><strong aria-hidden="true">2.7.</strong> ⭐️引用、借用、生命周期</a></li><li class="chapter-item "><a href="modules/modules.html"><strong aria-hidden="true">2.8.</strong> modules: mod keyword</a></li><li class="chapter-item "><a href="move_semantics/move_semantics.html"><strong aria-hidden="true">2.9.</strong> ✨move_semantics</a></li><li class="chapter-item "><a href="tests/tests.html"><strong aria-hidden="true">2.10.</strong> tests</a></li><li class="chapter-item "><a href="threads/threads.html"><strong aria-hidden="true">2.11.</strong> threads</a></li><li class="chapter-item "><a href="variables/variables.html"><strong aria-hidden="true">2.12.</strong> variables</a></li></ol></li><li class="chapter-item expanded "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Rust错题本</h1>
            <h4 class="menu-bar">日不见增 月有渐进 | 唯剃真我 方有成效｜ 惊涛拍案 千层雪起 | <a href="https://kuanhsiaokuo.github.io/think-tool-kit/">保持批判，有所取舍，知行合一, 方见真我</a> | 练武不练功
                到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="rust错题本"><a class="header" href="#rust错题本">Rust错题本</a></h1>
<h2 id="缘起"><a class="header" href="#缘起">缘起</a></h2>
<blockquote>
<p>灵感来自：<a href="https://github.com/rust-lang/rustlings">rust-lang/rustlings: Small exercises to get you used to reading and writing Rust code!</a></p>
</blockquote>
<p>余学Rust一载有余，深感其“一说就会，一写就废“的特点。在整理了几本电子书后，受到rustlings启发，觉得确实可以起一本“Rust错题本“.</p>
<h2 id="rustlings不错更需要自己整理"><a class="header" href="#rustlings不错更需要自己整理">rustlings不错，更需要自己整理</a></h2>
<p>rustlings使用起来确实很方便，其代码也值得研究，是常见的rust入门demo类型-命令行工具。但是它必须在电脑上运行，不适合随时练习，所以觉得mdbook在线运行会更方便。</p>
<h2 id="admonish-mdbook"><a class="header" href="#admonish-mdbook">admonish-mdbook</a></h2>
<p><a href="https://tommilligan.github.io/mdbook-admonish/reference.html">Reference - The mdbook-admonish book</a></p>
<h2 id="单元测试与main函数"><a class="header" href="#单元测试与main函数">单元测试与main函数</a></h2>
<p>rustlings默认代码中大都使用单元测试进行验证，这也和其本身用意相符：通过编译器的测试。但是我都手动转为main函数，这是为了方便在网页上可以在rust playground中执行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-to-book-chapter-mapping"><a class="header" href="#exercise-to-book-chapter-mapping">Exercise to Book Chapter mapping</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Exercise</th><th>Book Chapter</th></tr></thead><tbody>
<tr><td>variables</td><td>§3.1</td></tr>
<tr><td>functions</td><td>§3.3</td></tr>
<tr><td>if</td><td>§3.5</td></tr>
<tr><td>primitive_types</td><td>§3.2, §4.3</td></tr>
<tr><td>vecs</td><td>§8.1</td></tr>
<tr><td>move_semantics</td><td>§4.1-2</td></tr>
<tr><td>structs</td><td>§5.1, §5.3</td></tr>
<tr><td>enums</td><td>§6, §18.3</td></tr>
<tr><td>strings</td><td>§8.2</td></tr>
<tr><td>modules</td><td>§7</td></tr>
<tr><td>hashmaps</td><td>§8.3</td></tr>
<tr><td>options</td><td>§10.1</td></tr>
<tr><td>error_handling</td><td>§9</td></tr>
<tr><td>generics</td><td>§10</td></tr>
<tr><td>traits</td><td>§10.2</td></tr>
<tr><td>tests</td><td>§11.1</td></tr>
<tr><td>lifetimes</td><td>§10.3</td></tr>
<tr><td>iterators</td><td>§13.2-4</td></tr>
<tr><td>threads</td><td>§16.1-3</td></tr>
<tr><td>smart_pointers</td><td>§15, §16.3</td></tr>
<tr><td>macros</td><td>§19.6</td></tr>
<tr><td>clippy</td><td>§21.4</td></tr>
<tr><td>conversions</td><td>n/a</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Rust uses the <code>print!</code> and <code>println!</code> macros to print text to the console.</p>
<h2 id="further-information"><a class="header" href="#further-information">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello.html">Hello World</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/hello/print.html">Formatted print</a></li>
</ul>
<h2 id="rustlings-quiz"><a class="header" href="#rustlings-quiz">Rustlings Quiz</a></h2>
<details id="admonition-quiz1" class="admonition note">
<summary class="admonition-title">
<p>quiz1</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz1.rs}}
</code></pre></pre>
</div>
</details>
<details id="admonition-quiz2" class="admonition note">
<summary class="admonition-title">
<p>quiz2</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz2.rs}}
</code></pre></pre>
</div>
</details>
<details id="admonition-quiz3" class="admonition note">
<summary class="admonition-title">
<p>quiz3</p>
<p><a class="admonition-anchor-link" href="intro/intro.html#admonition-quiz3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">{{#include quiz3.rs}}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Rust has a couple of basic types that are directly implemented into the
compiler. In this section, we’ll go through the most important ones.</p>
<h2 id="further-information-1"><a class="header" href="#further-information-1">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html">Data Types</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch04-03-slices.html">The Slice Type</a></li>
</ul>
<h2 id="rustlings"><a class="header" href="#rustlings">Rustlings</a></h2>
<details id="admonition-primitive_types1-fill-in-the-rest-of-the-line-that-has-code-missing" class="admonition note">
<summary class="admonition-title">
<p>primitive_types1: Fill in the rest of the line that has code missing!</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types1-fill-in-the-rest-of-the-line-that-has-code-missing"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types1.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Booleans (`bool`)

    let is_morning = true;
    if is_morning {
        println!(&quot;Good morning!&quot;);
    }

    let // Finish the rest of this line like the example! Or make it be false!
    if is_evening {
        println!(&quot;Good evening!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-primitive_types2-fill-in-the-rest-of-the-line-that-has-code-missing" class="admonition note">
<summary class="admonition-title">
<p>primitive_types2: Fill in the rest of the line that has code missing!</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types2-fill-in-the-rest-of-the-line-that-has-code-missing"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types2.rs
// Fill in the rest of the line that has code missing!
// No hints, there's no tricks, just get used to typing these :)

// I AM NOT DONE

fn main() {
    // Characters (`char`)

    // Note the _single_ quotes, these are different from the double quotes
    // you've been seeing around.
    let my_first_initial = 'C';
    if my_first_initial.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if my_first_initial.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }

    let // Finish this line like the example! What's your favorite character?
    // Try a letter, try a number, try a special character, try a character
    // from a different language than your own, try an emoji!
    if your_character.is_alphabetic() {
        println!(&quot;Alphabetical!&quot;);
    } else if your_character.is_numeric() {
        println!(&quot;Numerical!&quot;);
    } else {
        println!(&quot;Neither alphabetic nor numeric!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-single-or-double-quotes-they-are-different" class="admonition tip">
<summary class="admonition-title">
<p>Hint: single or double quotes, they are different</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-hint-single-or-double-quotes-they-are-different"></a></p>
</summary>
<div>
<p>‘C’ is str, but “C” is &amp;str</p>
</div>
</details>
<hr />
<details id="admonition-primitive_types3-create-an-array-with-at-least-100-elements-in-it-where-the--is" class="admonition note">
<summary class="admonition-title">
<p>primitive_types3: Create an array with at least 100 elements in it where the ??? is.</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types3-create-an-array-with-at-least-100-elements-in-it-where-the--is"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types3.rs
// Create an array with at least 100 elements in it where the ??? is.
// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let a = ???

    if a.len() &gt;= 100 {
        println!(&quot;Wow, that's a big array!&quot;);
    } else {
        println!(&quot;Meh, I eat arrays like that for breakfast.&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-hint"></a></p>
</summary>
<div>
<p>There’s a shorthand to initialize Arrays with a certain size that does not
require you to type in 100 items (but you certainly can if you want!).
For example, you can do:
let array = [“Are we there yet?”; 10];</p>
<p>Bonus: what are some other things you could have that would return true
for <code>a.len() &gt;= 100</code>?</p>
</div>
</details>
<details id="admonition-solution" class="admonition success">
<summary class="admonition-title">
<p>solution</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-solution"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types3.rs
// Create an array with at least 100 elements in it where the ??? is.
// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand for a hint.

fn main() {
    let a = [&quot;a&quot;; 110];

    if a.len() &gt;= 100 {
        println!(&quot;Wow, that's a big array!&quot;);
    } else {
        println!(&quot;Meh, I eat arrays like that for breakfast.&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-primitive_types4-get-a-slice-out-of-array-a" class="admonition note">
<summary class="admonition-title">
<p>primitive_types4: Get a slice out of Array a </p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types4-get-a-slice-out-of-array-a"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types4.rs
// Get a slice out of Array a where the ??? is so that the test passes.
// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let a = [1, 2, 3, 4, 5];

    let nice_slice = ???

    assert_eq!([2, 3, 4], nice_slice)
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-primitive_types5-destructure-the-cat-tuple" class="admonition note">
<summary class="admonition-title">
<p>primitive_types5: Destructure the <em>cat</em> tuple</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types5-destructure-the-cat-tuple"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types5.rs
// Destructure the `cat` tuple so that the println will work.
// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let cat = (&quot;Furry McFurson&quot;, 3.5);
    let /* your pattern here */ = cat;

    println!(&quot;{} is {} years old.&quot;, name, age);
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-primitive_types6-use-a-tuple-index-to-access-the-second-element-of-numbers" class="admonition note">
<summary class="admonition-title">
<p>primitive_types6: Use a tuple index to access the second element of <em>numbers</em>.</p>
<p><a class="admonition-anchor-link" href="primitive_types/primitive_types.html#admonition-primitive_types6-use-a-tuple-index-to-access-the-second-element-of-numbers"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// primitive_types6.rs
// Use a tuple index to access the second element of `numbers`.
// You can put the expression for the second element where ??? is so that the test passes.
// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[test]
fn indexing_tuple() {
    let numbers = (1, 2, 3);
    // Replace below ??? with the tuple indexing syntax.
    let second = ???;

    assert_eq!(2, second,
        &quot;This is not the 2nd number in the tuple!&quot;)
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="strings-str-for-string-slice-and-string-for-owned-string"><a class="header" href="#strings-str-for-string-slice-and-string-for-owned-string">Strings: <code>&amp;str</code> for string slice and <code>String</code> for owned string</a></h1>
<p>Rust has two string types, a string slice (<code>&amp;str</code>) and an owned string (<code>String</code>).
We’re not going to dictate when you should use which one, but we’ll show you how
to identify and create them, as well as use them.</p>
<h2 id="further-information-2"><a class="header" href="#further-information-2">Further information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch08-02-strings.html">Strings: Storing UTF-8 Encoded Text - The Rust Programming Language</a></li>
<li><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/strings">rustlings-solutions-5/strings at main · gaveen/rustlings-solutions-5</a></li>
</ul>
<h2 id="rustlings-1"><a class="header" href="#rustlings-1">Rustlings</a></h2>
<details id="admonition-strings1-string---to_string" class="admonition note">
<summary class="admonition-title">
<p>strings1: String -&gt; to_string()</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings1-string---to_string"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings1.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let answer = current_favorite_color();
    println!(&quot;My current favorite color is {}&quot;, answer);
}

fn current_favorite_color() -&gt; String {
    &quot;blue&quot;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-hint"></a></p>
</summary>
<div>
<p>The <code>current_favorite_color</code> function is currently returning a string slice with the <code>'static</code>
lifetime. </p>
<p>We know this because the data of the string lives in our code itself – it doesn’t
come from a file or user input or another program – so it will live as long as our program
lives. </p>
<p>But it is still a <code>string slice</code>. There’s one way to create a <code>String</code> by converting a
string slice covered in the Strings chapter of the book, and another way that uses the <code>From</code>
trait.</p>
</div>
</details>
<details id="admonition-solution1-to_string" class="admonition success">
<summary class="admonition-title">
<p>solution1: to_string</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-solution1-to_string"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">fn current_favorite_color() -&gt; String {
    &quot;blue&quot;.to_string()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-from-trait" class="admonition success">
<summary class="admonition-title">
<p>solution2: From trait</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-solution2-from-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">fn current_favorite_color() -&gt; String {
    String::from(&quot;blue&quot;)
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-strings2-str---as_str" class="admonition note">
<summary class="admonition-title">
<p>strings2: &amp;str -&gt; as_str()</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings2-str---as_str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings2.rs
// Make me compile without changing the function signature!
// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let word = String::from(&quot;green&quot;); // Try not changing this line :)
    if is_a_color_word(word) {
        println!(&quot;That is a color word I know!&quot;);
    } else {
        println!(&quot;That is not a color word I know.&quot;);
    }
}

fn is_a_color_word(attempt: &amp;str) -&gt; bool {
    attempt == &quot;green&quot; || attempt == &quot;blue&quot; || attempt == &quot;red&quot;
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Yes, it would be really easy to fix this by just changing the value bound to <code>word</code> to be a
string slice instead of a <code>String</code>, wouldn’t it?? There is a way to add one character to line
9, though, that will coerce the <code>String</code> into a string slice.</p>
</div>
</details>
<details id="admonition-solution-as_str" class="admonition success">
<summary class="admonition-title">
<p>solution: as_str()</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-solution-as_str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">is_a_color_word(word.as_str())
</code></pre></pre>
</div>
</details>
<details id="admonition-strings3" class="admonition note">
<summary class="admonition-title">
<p>strings3</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings3.rs
// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn trim_me(input: &amp;str) -&gt; String {
    // TODO: Remove whitespace from both ends of a string!
    ? ? ?
}

fn compose_me(input: &amp;str) -&gt; String {
    // TODO: Add &quot; world!&quot; to the string! There's multiple ways to do this!
    ? ? ?
}

fn replace_me(input: &amp;str) -&gt; String {
    // TODO: Replace &quot;cars&quot; in the string with &quot;balloons&quot;!
    ? ? ?
}

// convert unit tests to main
fn main() {
    fn trim_a_string() {
        assert_eq!(trim_me(&quot;Hello!     &quot;), &quot;Hello!&quot;);
        assert_eq!(trim_me(&quot;  What's up!&quot;), &quot;What's up!&quot;);
        assert_eq!(trim_me(&quot;   Hola!  &quot;), &quot;Hola!&quot;);
    }

    fn compose_a_string() {
        assert_eq!(compose_me(&quot;Hello&quot;), &quot;Hello world!&quot;);
        assert_eq!(compose_me(&quot;Goodbye&quot;), &quot;Goodbye world!&quot;);
    }

    fn replace_a_string() {
        assert_eq!(replace_me(&quot;I think cars are cool&quot;), &quot;I think balloons are cool&quot;);
        assert_eq!(replace_me(&quot;I love to look at cars&quot;), &quot;I love to look at balloons&quot;);
    }
    trim_a_string();
    compose_a_string();
    replace_a_string();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn trim_a_string() {
        assert_eq!(trim_me(&quot;Hello!     &quot;), &quot;Hello!&quot;);
        assert_eq!(trim_me(&quot;  What's up!&quot;), &quot;What's up!&quot;);
        assert_eq!(trim_me(&quot;   Hola!  &quot;), &quot;Hola!&quot;);
    }

    #[test]
    fn compose_a_string() {
        assert_eq!(compose_me(&quot;Hello&quot;), &quot;Hello world!&quot;);
        assert_eq!(compose_me(&quot;Goodbye&quot;), &quot;Goodbye world!&quot;);
    }

    #[test]
    fn replace_a_string() {
        assert_eq!(replace_me(&quot;I think cars are cool&quot;), &quot;I think balloons are cool&quot;);
        assert_eq!(replace_me(&quot;I love to look at cars&quot;), &quot;I love to look at balloons&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>There’s tons of useful standard library functions for strings. Let’s try and use some of
them: <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.trim">String in std::string - Rust</a>!</p>
<p>For the compose_me method: You can either use the <code>format!</code> macro, or convert the string
slice into an owned string, which you can then freely extend.</p>
</div>
</details>
<details id="admonition-solution" class="admonition success">
<summary class="admonition-title">
<p>solution</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-solution"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn trim_me(input: &amp;str) -&gt; String {
    // Remove whitespace from the beginning and the end of a string!
    input.trim().to_string()
}

fn compose_me(input: &amp;str) -&gt; String {
    // Add  to the string! There's multiple ways to do this!
    input.to_owned() + &quot; world!&quot;
}

fn replace_me(input: &amp;str) -&gt; String {
    // Replace &quot;cars&quot; in the string with &quot;balloons&quot;!
    input.replace(&quot;cars&quot;, &quot;balloons&quot;)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-strings4" class="admonition note">
<summary class="admonition-title">
<p>strings4</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-strings4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// strings4.rs

// Ok, here are a bunch of values-- some are `String`s, some are `&amp;str`s. Your
// task is to call one of these two functions on each value depending on what
// you think each value is. That is, add either `string_slice` or `string`
// before the parentheses on each line. If you're right, it will compile!
// No hints this time!

// I AM NOT DONE

fn string_slice(arg: &amp;str) {
    println!(&quot;{}&quot;, arg);
}
fn string(arg: String) {
    println!(&quot;{}&quot;, arg);
}

fn main() {
    ???(&quot;blue&quot;);
    ???(&quot;red&quot;.to_string());
    ???(String::from(&quot;hi&quot;));
    ???(&quot;rust is fun!&quot;.to_owned());
    ???(&quot;nice weather&quot;.into());
    ???(format!(&quot;Interpolation {}&quot;, &quot;Station&quot;));
    ???(&amp;String::from(&quot;abc&quot;)[0..1]);
    ???(&quot;  hello there &quot;.trim());
    ???(&quot;Happy Monday!&quot;.to_string().replace(&quot;Mon&quot;, &quot;Tues&quot;));
    ???(&quot;mY sHiFt KeY iS sTiCkY&quot;.to_lowercase());
}
</code></pre></pre>
</div>
</details>
<details id="admonition-no-hint" class="admonition tip">
<summary class="admonition-title">
<p>No Hint</p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-no-hint"></a></p>
</summary>
<div>
</div>
</details>
<details id="admonition-solution-distinguish-string-and-str" class="admonition success">
<summary class="admonition-title">
<p>solution: distinguish <em>String</em> and <em>&amp;str</em></p>
<p><a class="admonition-anchor-link" href="strings/strings.html#admonition-solution-distinguish-string-and-str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    string_slice(&quot;blue&quot;);
    string(&quot;red&quot;.to_string());
    string(String::from(&quot;hi&quot;));
    string(&quot;rust is fun!&quot;.to_owned());
    string(&quot;nice weather&quot;.into());
    string(format!(&quot;Interpolation {}&quot;, &quot;Station&quot;));
    string_slice(&amp;String::from(&quot;abc&quot;)[0..1]);
    string_slice(&quot;  hello there &quot;.trim());
    string(&quot;Happy Monday!&quot;.to_string().replace(&quot;Mon&quot;, &quot;Tues&quot;));
    string(&quot;mY sHiFt KeY iS sTiCkY&quot;.to_lowercase());
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Vectors are one of the most-used Rust data structures. In other programming
languages, they’d simply be called Arrays, but since Rust operates on a
bit of a lower level, an array in Rust is stored on the stack (meaning it
can’t grow or shrink, and the size needs to be known at compile time),
and a Vector is stored in the heap (where these restrictions do not apply).</p>
<p>Vectors are a bit of a later chapter in the book, but we think that they’re
useful enough to talk about them a bit earlier. We shall be talking about
the other useful data structure, hash maps, later.</p>
<h2 id="further-information-3"><a class="header" href="#further-information-3">Further information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch08-01-vectors.html">Vectors: Storing Lists of The Same Type of Values - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a></li>
<li><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/vecs">rustlings-solutions-5/vecs at main · gaveen/rustlings-solutions-5</a></li>
</ul>
<h2 id="rustlings-2"><a class="header" href="#rustlings-2">Rustlings</a></h2>
<details id="admonition-vecs1-i32-4-or-vec" class="admonition note">
<summary class="admonition-title">
<p>vecs1: [i32; 4] or vec!<i32></p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-vecs1-i32-4-or-vec"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// vecs1.rs
// Your task is to create a `Vec` which holds the exact same elements
// as in the array `a`.
// Make me compile and pass the test!
// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) {
    let a = [10, 20, 30, 40]; // a plain array
    let v = // TODO: declare your vector here with the macro for vectors

    (a, v)
}

// convert unit tests to main here
fn main() {
    let (a, v) = array_and_vec();
    assert_eq!(a, v[..]);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_array_and_vec_similarity() {
        let (a, v) = array_and_vec();
        assert_eq!(a, v[..]);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-hint"></a></p>
</summary>
<div>
<p>In Rust, there are two ways to define a Vector.</p>
<ol>
<li>One way is to use the <code>Vec::new()</code> function to create a new vector
and fill it with the <code>push()</code> method.</li>
<li>The second way, which is simpler is to use the <code>vec![]</code> macro and
define your elements inside the square brackets.
Check this chapter: <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch08-01-vectors.html">Vectors: Storing Lists of The Same Type of Values - The Rust Programming Language</a>
of the Rust book to learn more.</li>
</ol>
</div>
</details>
<details id="admonition-solution1" class="admonition success">
<summary class="admonition-title">
<p>solution1</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-solution1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">let v = vec![10, 20, 30, 40];
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-vecs2" class="admonition note">
<summary class="admonition-title">
<p>vecs2</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-vecs2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// vecs2.rs
// A Vec of even numbers is given. Your task is to complete the loop
// so that each number in the Vec is multiplied by 2.
//
// Make me pass the test!
//
// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for i in v.iter_mut() {
        // TODO: Fill this up so that each element in the Vec `v` is
        // multiplied by 2.
        ???
    }

    // At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.iter().map(|num| {
        // TODO: Do the same thing as above - but instead of mutating the
        // Vec, you can just return the new number!
        ???
    }).collect()
}

// convert unit tests to main here
fn main(){
    fn test_vec_loop() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }

    fn test_vec_map() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }
    test_vec_loop();
    test_vec_map();

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_loop() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_loop(v.clone());

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }

    #[test]
    fn test_vec_map() {
        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();
        let ans = vec_map(&amp;v);

        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Hint 1: <code>i</code> is each element from the Vec as they are being iterated. Can you try
multiplying this?</p>
<p>Hint 2: For the first function, there’s a way to directly access the numbers stored
in the Vec, using the * dereference operator. You can both access and write to the
number that way.</p>
<p>After you’ve completed both functions, decide for yourself which approach you like
better. What do you think is the more commonly used pattern under Rust developers?</p>
</div>
</details>
<details id="admonition-solution1-1" class="admonition success">
<summary class="admonition-title">
<p>solution1</p>
<p><a class="admonition-anchor-link" href="vecs/vecs.html#admonition-solution1-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for i in v.iter_mut() {
      *i *= 2;
    }

    // At this point, `v` should be equal to [4, 8, 12, 16, 20].
    v
}

fn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.iter().map(|num| {
        num*2
    }).collect()
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmaps"><a class="header" href="#hashmaps">Hashmaps</a></h1>
<p>A <em>hash map</em> allows you to associate a value with a particular key.
You may also know this by the names <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><em>unordered map</em> in C++</a>,
<a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries"><em>dictionary</em> in Python</a> or an <em>associative array</em> in other languages.</p>
<p>This is the other data structure that we’ve been talking about before, when
talking about Vecs.</p>
<h2 id="further-information-4"><a class="header" href="#further-information-4">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html">Storing Keys with Associated Values in Hash Maps</a></li>
</ul>
<h2 id="rustlings-3"><a class="header" href="#rustlings-3">Rustlings</a></h2>
<details id="admonition-hashmaps1" class="admonition note">
<summary class="admonition-title">
<p>hashmaps1</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps1.rs
// A basket of fruits in the form of a hash map needs to be defined.
// The key represents the name of the fruit and the value represents
// how many of that particular fruit is in the basket. You have to put
// at least three different types of fruits (e.g apple, banana, mango)
// in the basket and the total count of all the fruits should be at
// least five.
//
// Make me compile and pass the tests!
//
// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

fn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {
    let mut basket = // TODO: declare your hash map here.

    // Two bananas are already given for you :)
    basket.insert(String::from(&quot;banana&quot;), 2);

    // TODO: Put more fruits in your basket here.

    basket
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn at_least_three_types_of_fruits() {
        let basket = fruit_basket();
        assert!(basket.len() &gt;= 3);
    }

    #[test]
    fn at_least_five_fruits() {
        let basket = fruit_basket();
        assert!(basket.values().sum::&lt;u32&gt;() &gt;= 5);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hashmaps2" class="admonition note">
<summary class="admonition-title">
<p>hashmaps2</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps2.rs

// A basket of fruits in the form of a hash map is given. The key
// represents the name of the fruit and the value represents how many
// of that particular fruit is in the basket. You have to put *MORE
// THAN 11* fruits in the basket. Three types of fruits - Apple (4),
// Mango (2) and Lychee (5) are already given in the basket. You are
// not allowed to insert any more of these fruits!
//
// Make me pass the tests!
//
// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Hash, PartialEq, Eq)]
enum Fruit {
    Apple,
    Banana,
    Mango,
    Lychee,
    Pineapple,
}

fn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {
    let fruit_kinds = vec![
        Fruit::Apple,
        Fruit::Banana,
        Fruit::Mango,
        Fruit::Lychee,
        Fruit::Pineapple,
    ];

    for fruit in fruit_kinds {
        // TODO: Put new fruits if not already present. Note that you
        // are not allowed to put any type of fruit that's already
        // present!
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_fruit_basket() -&gt; HashMap&lt;Fruit, u32&gt; {
        let mut basket = HashMap::&lt;Fruit, u32&gt;::new();
        basket.insert(Fruit::Apple, 4);
        basket.insert(Fruit::Mango, 2);
        basket.insert(Fruit::Lychee, 5);

        basket
    }

    #[test]
    fn test_given_fruits_are_not_modified() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        assert_eq!(*basket.get(&amp;Fruit::Apple).unwrap(), 4);
        assert_eq!(*basket.get(&amp;Fruit::Mango).unwrap(), 2);
        assert_eq!(*basket.get(&amp;Fruit::Lychee).unwrap(), 5);
    }

    #[test]
    fn at_least_five_types_of_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count_fruit_kinds = basket.len();
        assert!(count_fruit_kinds &gt;= 5);
    }

    #[test]
    fn greater_than_eleven_fruits() {
        let mut basket = get_fruit_basket();
        fruit_basket(&amp;mut basket);
        let count = basket.values().sum::&lt;u32&gt;();
        assert!(count &gt; 11);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hashmaps3" class="admonition note">
<summary class="admonition-title">
<p>hashmaps3</p>
<p><a class="admonition-anchor-link" href="hashmaps/hashmaps.html#admonition-hashmaps3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// hashmaps3.rs

// A list of scores (one per line) of a soccer match is given. Each line
// is of the form :
// &lt;team_1_name&gt;,&lt;team_2_name&gt;,&lt;team_1_goals&gt;,&lt;team_2_goals&gt;
// Example: England,France,4,2 (England scored 4 goals, France 2).

// You have to build a scores table containing the name of the team, goals
// the team scored, and goals the team conceded. One approach to build
// the scores table is to use a Hashmap. The solution is partially
// written to use a Hashmap, complete it to pass the test.

// Make me pass the tests!

// Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::collections::HashMap;

// A structure to store team name and its goal details.
struct Team {
    name: String,
    goals_scored: u8,
    goals_conceded: u8,
}

fn build_scores_table(results: String) -&gt; HashMap&lt;String, Team&gt; {
    // The name of the team is the key and its associated struct is the value.
    let mut scores: HashMap&lt;String, Team&gt; = HashMap::new();

    for r in results.lines() {
        let v: Vec&lt;&amp;str&gt; = r.split(',').collect();
        let team_1_name = v[0].to_string();
        let team_1_score: u8 = v[2].parse().unwrap();
        let team_2_name = v[1].to_string();
        let team_2_score: u8 = v[3].parse().unwrap();
        // TODO: Populate the scores table with details extracted from the
        // current line. Keep in mind that goals scored by team_1
        // will be the number of goals conceded from team_2, and similarly
        // goals scored by team_2 will be the number of goals conceded by
        // team_1.
    }
    scores
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_results() -&gt; String {
        let results = &quot;&quot;.to_string()
            + &quot;England,France,4,2\n&quot;
            + &quot;France,Italy,3,1\n&quot;
            + &quot;Poland,Spain,2,0\n&quot;
            + &quot;Germany,England,2,1\n&quot;;
        results
    }

    #[test]
    fn build_scores() {
        let scores = build_scores_table(get_results());

        let mut keys: Vec&lt;&amp;String&gt; = scores.keys().collect();
        keys.sort();
        assert_eq!(
            keys,
            vec![&quot;England&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;Poland&quot;, &quot;Spain&quot;]
        );
    }

    #[test]
    fn validate_team_score_1() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&quot;England&quot;).unwrap();
        assert_eq!(team.goals_scored, 5);
        assert_eq!(team.goals_conceded, 4);
    }

    #[test]
    fn validate_team_score_2() {
        let scores = build_scores_table(get_results());
        let team = scores.get(&quot;Spain&quot;).unwrap();
        assert_eq!(team.goals_scored, 0);
        assert_eq!(team.goals_conceded, 2);
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Rust has three struct types: a classic C struct, a tuple struct, and a unit struct.</p>
<h2 id="further-information-5"><a class="header" href="#further-information-5">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">Structures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">Method Syntax</a></li>
</ul>
<h2 id="rustlings-4"><a class="header" href="#rustlings-4">Rustlings</a></h2>
<details id="admonition-structs1" class="admonition note">
<summary class="admonition-title">
<p>structs1</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs1.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct ColorClassicStruct {
    // TODO: Something goes here
}

struct ColorTupleStruct(/* TODO: Something goes here */);

#[derive(Debug)]
struct UnitLikeStruct;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classic_c_structs() {
        // TODO: Instantiate a classic c struct!
        // let green =

        assert_eq!(green.red, 0);
        assert_eq!(green.green, 255);
        assert_eq!(green.blue, 0);
    }

    #[test]
    fn tuple_structs() {
        // TODO: Instantiate a tuple struct!
        // let green =

        assert_eq!(green.0, 0);
        assert_eq!(green.1, 255);
        assert_eq!(green.2, 0);
    }

    #[test]
    fn unit_structs() {
        // TODO: Instantiate a unit-like struct!
        // let unit_like_struct =
        let message = format!(&quot;{:?}s are fun!&quot;, unit_like_struct);

        assert_eq!(message, &quot;UnitLikeStructs are fun!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-structs2" class="admonition note">
<summary class="admonition-title">
<p>structs2</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs2.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
struct Order {
    name: String,
    year: u32,
    made_by_phone: bool,
    made_by_mobile: bool,
    made_by_email: bool,
    item_number: u32,
    count: u32,
}

fn create_order_template() -&gt; Order {
    Order {
        name: String::from(&quot;Bob&quot;),
        year: 2019,
        made_by_phone: false,
        made_by_mobile: false,
        made_by_email: true,
        item_number: 123,
        count: 0,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn your_order() {
        let order_template = create_order_template();
        // TODO: Create your own order using the update syntax and template above!
        // let your_order =
        assert_eq!(your_order.name, &quot;Hacker in Rust&quot;);
        assert_eq!(your_order.year, order_template.year);
        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);
        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);
        assert_eq!(your_order.made_by_email, order_template.made_by_email);
        assert_eq!(your_order.item_number, order_template.item_number);
        assert_eq!(your_order.count, 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-structs3" class="admonition note">
<summary class="admonition-title">
<p>structs3</p>
<p><a class="admonition-anchor-link" href="structs/structs.html#admonition-structs3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// structs3.rs
// Structs contain data, but can also have logic. In this exercise we have
// defined the Package struct and we want to test some logic attached to it.
// Make the code compile and the tests pass!
// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
struct Package {
    sender_country: String,
    recipient_country: String,
    weight_in_grams: i32,
}

impl Package {
    fn new(sender_country: String, recipient_country: String, weight_in_grams: i32) -&gt; Package {
        if weight_in_grams &lt;= 0 {
            panic!(&quot;Can not ship a weightless package.&quot;)
        } else {
            Package {
                sender_country,
                recipient_country,
                weight_in_grams,
            }
        }
    }

    fn is_international(&amp;self) -&gt; ??? {
        // Something goes here...
    }

    fn get_fees(&amp;self, cents_per_gram: i32) -&gt; ??? {
        // Something goes here...
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn fail_creating_weightless_package() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Austria&quot;);

        Package::new(sender_country, recipient_country, -2210);
    }

    #[test]
    fn create_international_package() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Russia&quot;);

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(package.is_international());
    }

    #[test]
    fn create_local_package() {
        let sender_country = String::from(&quot;Canada&quot;);
        let recipient_country = sender_country.clone();

        let package = Package::new(sender_country, recipient_country, 1200);

        assert!(!package.is_international());
    }

    #[test]
    fn calculate_transport_fees() {
        let sender_country = String::from(&quot;Spain&quot;);
        let recipient_country = String::from(&quot;Spain&quot;);

        let cents_per_gram = 3;

        let package = Package::new(sender_country, recipient_country, 1500);

        assert_eq!(package.get_fees(cents_per_gram), 4500);
        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Rust allows you to define types called “enums” which enumerate possible values.
Enums are a feature in many languages, but their capabilities differ in each language. Rust’s enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.
Useful in combination with enums is Rust’s “pattern matching” facility, which makes it easy to run different code for different values of an enumeration.</p>
<h2 id="further-information-6"><a class="header" href="#further-information-6">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Enums</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">Pattern syntax</a></li>
</ul>
<h2 id="rustlings-5"><a class="header" href="#rustlings-5">Rustlings</a></h2>
<details id="admonition-enums1" class="admonition note">
<summary class="admonition-title">
<p>enums1</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums1.rs
// No hints this time! ;)

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define a few types of messages as used below
}

fn main() {
    println!(&quot;{:?}&quot;, Message::Quit);
    println!(&quot;{:?}&quot;, Message::Echo);
    println!(&quot;{:?}&quot;, Message::Move);
    println!(&quot;{:?}&quot;, Message::ChangeColor);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-enums2" class="admonition note">
<summary class="admonition-title">
<p>enums2</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums2.rs
// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug)]
enum Message {
    // TODO: define the different variants used below
}

impl Message {
    fn call(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}

fn main() {
    let messages = [
        Message::Move { x: 10, y: 30 },
        Message::Echo(String::from(&quot;hello world&quot;)),
        Message::ChangeColor(200, 255, 255),
        Message::Quit,
    ];

    for message in &amp;messages {
        message.call();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-enums3" class="admonition note">
<summary class="admonition-title">
<p>enums3</p>
<p><a class="admonition-anchor-link" href="enums/enums.html#admonition-enums3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// enums3.rs
// Address all the TODOs to make the tests pass!
// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

enum Message {
    // TODO: implement the message variant types based on their usage below
}

struct Point {
    x: u8,
    y: u8,
}

struct State {
    color: (u8, u8, u8),
    position: Point,
    quit: bool,
}

impl State {
    fn change_color(&amp;mut self, color: (u8, u8, u8)) {
        self.color = color;
    }

    fn quit(&amp;mut self) {
        self.quit = true;
    }

    fn echo(&amp;self, s: String) {
        println!(&quot;{}&quot;, s);
    }

    fn move_position(&amp;mut self, p: Point) {
        self.position = p;
    }

    fn process(&amp;mut self, message: Message) {
        // TODO: create a match expression to process the different message variants
        // Remember: When passing a tuple as a function argument, you'll need extra parentheses: fn function((t, u, p, l, e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_message_call() {
        let mut state = State {
            quit: false,
            position: Point { x: 0, y: 0 },
            color: (0, 0, 0),
        };
        state.process(Message::ChangeColor(255, 0, 255));
        state.process(Message::Echo(String::from(&quot;hello world&quot;)));
        state.process(Message::Move(Point { x: 10, y: 15 }));
        state.process(Message::Quit);

        assert_eq!(state.color, (255, 0, 255));
        assert_eq!(state.position.x, 10);
        assert_eq!(state.position.y, 15);
        assert_eq!(state.quit, true);
    }
}
</code></pre></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/std.html">⭐️Std library types - The Rust Programming Language</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>This section will teach you about Iterators.</p>
<h2 id="further-information-7"><a class="header" href="#further-information-7">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterator</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/">Iterator documentation</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/standard_library_types">rustlings-solutions-5/standard_library_types at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<h2 id="rustlings-6"><a class="header" href="#rustlings-6">Rustlings</a></h2>
<details id="admonition-iterators1" class="admonition note">
<summary class="admonition-title">
<p>iterators1</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators1.rs
//
//  Make me compile by filling in the `???`s
//
// When performing operations on elements within a collection, iterators are essential.
// This module helps you get familiar with the structure of using an iterator and
// how to go through elements within an iterable collection.
//
// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main () {
    let my_fav_fruits = vec![&quot;banana&quot;, &quot;custard apple&quot;, &quot;avocado&quot;, &quot;peach&quot;, &quot;raspberry&quot;];

    let mut my_iterable_fav_fruits = ???;   // TODO: Step 1

    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;banana&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 2
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;avocado&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 3
    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;&quot;raspberry&quot;));
    assert_eq!(my_iterable_fav_fruits.next(), ???);     // TODO: Step 4
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators2" class="admonition note">
<summary class="admonition-title">
<p>iterators2</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators2.rs
// In this exercise, you'll learn some of the unique advantages that iterators
// can offer. Follow the steps to complete the exercise.
// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Step 1.
// Complete the `capitalize_first` function.
// &quot;hello&quot; -&gt; &quot;Hello&quot;
pub fn capitalize_first(input: &amp;str) -&gt; String {
    let mut c = input.chars();
    match c.next() {
        None =&gt; String::new(),
        Some(first) =&gt; ???,
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// [&quot;hello&quot;, &quot;world&quot;] -&gt; [&quot;Hello&quot;, &quot;World&quot;]
pub fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; {
    vec![]
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// [&quot;hello&quot;, &quot; &quot;, &quot;world&quot;] -&gt; &quot;Hello World&quot;
pub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String {
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first(&quot;hello&quot;), &quot;Hello&quot;);
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(&quot;&quot;), &quot;&quot;);
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec![&quot;hello&quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_vector(&amp;words), [&quot;Hello&quot;, &quot;World&quot;]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec![&quot;hello&quot;, &quot; &quot;, &quot;world&quot;];
        assert_eq!(capitalize_words_string(&amp;words), &quot;Hello World&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators3" class="admonition note">
<summary class="admonition-title">
<p>iterators3</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators3.rs
// This is a bigger exercise than most of the others! You can do it!
// Here is your mission, should you choose to accept it:
// 1. Complete the divide function to get the first four tests to pass.
// 2. Get the remaining tests to pass by completing the result_with_list and
//    list_of_results functions.
// Execute `rustlings hint iterators3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(Debug, PartialEq, Eq)]
pub enum DivisionError {
    NotDivisible(NotDivisibleError),
    DivideByZero,
}

#[derive(Debug, PartialEq, Eq)]
pub struct NotDivisibleError {
    dividend: i32,
    divisor: i32,
}

// Calculate `a` divided by `b` if `a` is evenly divisible by `b`.
// Otherwise, return a suitable error.
pub fn divide(a: i32, b: i32) -&gt; Result&lt;i32, DivisionError&gt; {
    todo!();
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: Ok([1, 11, 1426, 3])
fn result_with_list() -&gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

// Complete the function and return a value of the correct type so the test passes.
// Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]
fn list_of_results() -&gt; () {
    let numbers = vec![27, 297, 38502, 81];
    let division_results = numbers.into_iter().map(|n| divide(n, 27));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(divide(81, 9), Ok(9));
    }

    #[test]
    fn test_not_divisible() {
        assert_eq!(
            divide(81, 6),
            Err(DivisionError::NotDivisible(NotDivisibleError {
                dividend: 81,
                divisor: 6
            }))
        );
    }

    #[test]
    fn test_divide_by_0() {
        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));
    }

    #[test]
    fn test_divide_0_by_something() {
        assert_eq!(divide(0, 81), Ok(0));
    }

    #[test]
    fn test_result_with_list() {
        assert_eq!(format!(&quot;{:?}&quot;, result_with_list()), &quot;Ok([1, 11, 1426, 3])&quot;);
    }

    #[test]
    fn test_list_of_results() {
        assert_eq!(
            format!(&quot;{:?}&quot;, list_of_results()),
            &quot;[Ok(1), Ok(11), Ok(1426), Ok(3)]&quot;
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators4" class="admonition note">
<summary class="admonition-title">
<p>iterators4</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators4.rs
// Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn factorial(num: u64) -&gt; u64 {
    // Complete this function to return the factorial of num
    // Do not use:
    // - return
    // Try not to use:
    // - imperative style loops (for, while)
    // - additional variables
    // For an extra challenge, don't use:
    // - recursion
    // Execute `rustlings hint iterators4` for hints.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn factorial_of_0() {
        assert_eq!(1, factorial(0));
    }

    #[test]
    fn factorial_of_1() {
        assert_eq!(1, factorial(1));
    }
    #[test]
    fn factorial_of_2() {
        assert_eq!(2, factorial(2));
    }

    #[test]
    fn factorial_of_4() {
        assert_eq!(24, factorial(4));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-iterators5" class="admonition note">
<summary class="admonition-title">
<p>iterators5</p>
<p><a class="admonition-anchor-link" href="iterators/iterators.html#admonition-iterators5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// iterators5.rs
// Let's define a simple model to track Rustlings exercise progress. Progress
// will be modelled using a hash map. The name of the exercise is the key and
// the progress is the value. Two counting functions were created to count the
// number of exercises with a given progress. These counting functions use
// imperative style for loops. Recreate this counting functionality using
// iterators. Only the two iterator methods (count_iterator and
// count_collection_iterator) need to be modified.
// Execute `rustlings hint iterators5` or use the `hint` watch subcommand for a hint.
//
// Make the code compile and the tests pass.

// I AM NOT DONE

use std::collections::HashMap;

#[derive(Clone, Copy, PartialEq, Eq)]
enum Progress {
    None,
    Some,
    Complete,
}

fn count_for(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {
    let mut count = 0;
    for val in map.values() {
        if val == &amp;value {
            count += 1;
        }
    }
    count
}

fn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {
    // map is a hashmap with String keys and Progress values.
    // map = { &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... }
    todo!();
}

fn count_collection_for(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {
    let mut count = 0;
    for map in collection {
        for val in map.values() {
            if val == &amp;value {
                count += 1;
            }
        }
    }
    count
}

fn count_collection_iterator(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {
    // collection is a slice of hashmaps.
    // collection = [{ &quot;variables1&quot;: Complete, &quot;from_str&quot;: None, ... },
    //     { &quot;variables2&quot;: Complete, ... }, ... ]
    todo!();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_complete() {
        let map = get_map();
        assert_eq!(3, count_iterator(&amp;map, Progress::Complete));
    }

    #[test]
    fn count_equals_for() {
        let map = get_map();
        assert_eq!(
            count_for(&amp;map, Progress::Complete),
            count_iterator(&amp;map, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_complete() {
        let collection = get_vec_map();
        assert_eq!(
            6,
            count_collection_iterator(&amp;collection, Progress::Complete)
        );
    }

    #[test]
    fn count_collection_equals_for() {
        let collection = get_vec_map();
        assert_eq!(
            count_collection_for(&amp;collection, Progress::Complete),
            count_collection_iterator(&amp;collection, Progress::Complete)
        );
    }

    fn get_map() -&gt; HashMap&lt;String, Progress&gt; {
        use Progress::*;

        let mut map = HashMap::new();
        map.insert(String::from(&quot;variables1&quot;), Complete);
        map.insert(String::from(&quot;functions1&quot;), Complete);
        map.insert(String::from(&quot;hashmap1&quot;), Complete);
        map.insert(String::from(&quot;arc1&quot;), Some);
        map.insert(String::from(&quot;as_ref_mut&quot;), None);
        map.insert(String::from(&quot;from_str&quot;), None);

        map
    }

    fn get_vec_map() -&gt; Vec&lt;HashMap&lt;String, Progress&gt;&gt; {
        use Progress::*;

        let map = get_map();

        let mut other = HashMap::new();
        other.insert(String::from(&quot;variables2&quot;), Complete);
        other.insert(String::from(&quot;functions2&quot;), Complete);
        other.insert(String::from(&quot;if1&quot;), Complete);
        other.insert(String::from(&quot;from_into&quot;), None);
        other.insert(String::from(&quot;try_from_into&quot;), None);

        vec![map, other]
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<!--ts-->
<ul>
<li><a href="smart_pointers/smart_pointer.html#smart-pointers">Smart Pointers</a>
<ul>
<li><a href="smart_pointers/smart_pointer.html#further-information">Further Information</a></li>
<li><a href="smart_pointers/smart_pointer.html#rustlings">Rustlings</a>
<ul>
<li><a href="smart_pointers/smart_pointer.html#arc">Arc</a></li>
<li><a href="smart_pointers/smart_pointer.html#box">Box</a></li>
<li><a href="smart_pointers/smart_pointer.html#cow-clone-on-write">Cow: Clone-On-Write</a></li>
<li><a href="smart_pointers/smart_pointer.html#rc">Rc</a></li>
<li><a href="smart_pointers/smart_pointer.html#memory-leak">Memory Leak</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Thu Mar 16 14:35:12 UTC 2023 -->
<!--te-->
<p>In Rust, smart pointers are variables that contain an address in memory and reference some other data, but they also have additional metadata and capabilities.
Smart pointers in Rust often own the data they point to, while references only borrow data.</p>
<h2 id="further-information-8"><a class="header" href="#further-information-8">Further Information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_smart_pointer.html">智能指针 - Anatomy In First Rust Programming Class 🦀</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-00-smart-pointers.html">✨Smart Pointers: Heap、Deref、Drop、Rc、RefCell、Reference Cycle - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-01-box.html">Heap: Using Box<T> to Point to Data on the Heap - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-04-rc.html">Rc<T>(Reference Counting): single-threaded scenarios, immutable references of multiple owners, the Reference Counted Smart Pointer - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch16-03-shared-state.html">Shared-State Concurrency - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow Documentation</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/standard_library_types">rustlings-solutions-5/standard_library_types at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<h2 id="rustlings-7"><a class="header" href="#rustlings-7">Rustlings</a></h2>
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<ol>
<li>In this exercise, we are given a Vec of u32 called “numbers” with values ranging
from 0 to 99 – [ 0, 1, 2, …, 98, 99 ]</li>
<li>We would like to use this set of numbers within 8 different threads simultaneously.</li>
<li>Each thread is going to get the sum of every eighth value, with an offset.</li>
</ol>
<ul>
<li>The first thread (offset 0), will sum 0, 8, 16, …</li>
<li>The second thread (offset 1), will sum 1, 9, 17, …</li>
<li>The third thread (offset 2), will sum 2, 10, 18, …</li>
<li>…</li>
<li>The eighth thread (offset 7), will sum 7, 15, 23, …</li>
</ul>
<blockquote>
<p>Because we are using threads, our values need to be <code>thread-safe</code>. Therefore,
we are using Arc. We need to make a change in each of the two TODOs.</p>
</blockquote>
<ol>
<li>Make this code compile by filling in a value for <code>shared_numbers</code> where the
first TODO comment is</li>
<li>and create an initial binding for <code>child_numbers</code> where the second TODO comment is.</li>
</ol>
<blockquote>
<p>Try not to create any copies of the <code>numbers</code> Vec!</p>
</blockquote>
<details id="admonition-arc1-using-arc-to-keep-thread-safe" class="admonition bug">
<summary class="admonition-title">
<p>arc1: Using Arc to keep <em>thread-safe</em></p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-arc1-using-arc-to-keep-thread-safe"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// arc1.rs
// In this exercise, we are given a Vec of u32 called &quot;numbers&quot; with values ranging
// from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ]
// We would like to use this set of numbers within 8 different threads simultaneously.
// Each thread is going to get the sum of every eighth value, with an offset.
// The first thread (offset 0), will sum 0, 8, 16, ...
// The second thread (offset 1), will sum 1, 9, 17, ...
// The third thread (offset 2), will sum 2, 10, 18, ...
// ...
// The eighth thread (offset 7), will sum 7, 15, 23, ...

// Because we are using threads, our values need to be thread-safe.  Therefore,
// we are using Arc.  We need to make a change in each of the two TODOs.


// Make this code compile by filling in a value for `shared_numbers` where the
// first TODO comment is, and create an initial binding for `child_numbers`
// where the second TODO comment is. Try not to create any copies of the `numbers` Vec!
// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = // TODO
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = // TODO
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-hint"></a></p>
</summary>
<div>
<ol>
<li>Make <code>shared_numbers</code> be an <code>Arc</code> from the numbers vector. </li>
<li>Then, in order
to avoid creating a copy of <code>numbers</code>, you’ll need to create <code>child_numbers</code>
inside the loop but still in the main thread.</li>
<li><code>child_numbers</code> should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.</li>
</ol>
<blockquote>
<p>This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Concurrency Chapter in the book:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch16-00-concurrency.html">Fearless Concurrency - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<details id="admonition-solution-arcnew" class="admonition success">
<summary class="admonition-title">
<p>solution: Arc::new()</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-solution-arcnew"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">#![forbid(unused_imports)] // Do not change this, (or the next) line.
use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers); // filling in a value for `shared_numbers`
    let mut joinhandles = Vec::new();

    for offset in 0..8 {
        let child_numbers = shared_numbers.clone(); // create an initial binding for `child_numbers`
        joinhandles.push(thread::spawn(move || {
            let sum: u32 = child_numbers.iter().filter(|n| *n % 8 == offset).sum();
            println!(&quot;Sum of offset {} is {}&quot;, offset, sum);
        }));
    }
    for handle in joinhandles.into_iter() {
        handle.join().unwrap();
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_1_box.html">Box - Anatomy In First Rust Programming Class 🦀</a></li>
</ul>
<blockquote>
<p>At compile time, Rust needs to know <code>how much space a type takes up</code>. This becomes problematic
for <code>recursive types</code>, where a value can have as part of itself another value of the same type.</p>
</blockquote>
<p>To get around the issue, we can use a <code>Box</code> - a smart pointer used to store data on the heap,
which also allows us to wrap a recursive type.</p>
<p>The recursive type we’re implementing in this exercise is the <code>cons list</code> - a data structure
frequently found in functional programming languages. Each item in a cons list contains two
elements: the value of the current item and the next item. The last item is a value called <code>Nil</code>.</p>
<ul>
<li>Step 1: use a <code>Box</code> in the enum definition to make the code compile</li>
<li>Step 2: create both empty and non-empty cons lists by replacing <code>todo!()</code></li>
</ul>
<details id="admonition-box1" class="admonition note">
<summary class="admonition-title">
<p>box1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-box1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// box1.rs
//
// At compile time, Rust needs to know how much space a type takes up. This becomes problematic
// for recursive types, where a value can have as part of itself another value of the same type.
// To get around the issue, we can use a `Box` - a smart pointer used to store data on the heap,
// which also allows us to wrap a recursive type.
//
// The recursive type we're implementing in this exercise is the `cons list` - a data structure
// frequently found in functional programming languages. Each item in a cons list contains two
// elements: the value of the current item and the next item. The last item is a value called `Nil`.
//
// Step 1: use a `Box` in the enum definition to make the code compile
// Step 2: create both empty and non-empty cons lists by replacing `todo!()`
//
// Note: the tests should not be changed
//
// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, List),
    Nil,
}

fn main() {
    println!(&quot;This is an empty cons list: {:?}&quot;, create_empty_list());
    println!(
        &quot;This is a non-empty cons list: {:?}&quot;,
        create_non_empty_list()
    );
    // convert unit tests to main
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
    test_create_empty_list();
    test_create_non_empty_list();
}

pub fn create_empty_list() -&gt; List {
    todo!()
}

pub fn create_non_empty_list() -&gt; List {
    todo!()
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_empty_list() {
        assert_eq!(List::Nil, create_empty_list())
    }

    #[test]
    fn test_create_non_empty_list() {
        assert_ne!(create_empty_list(), create_non_empty_list())
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-hint-1"></a></p>
</summary>
<div>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<p>The compiler’s message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our <code>List</code> inside a <code>Box</code>. </p>
<blockquote>
<p>More details in the book here: <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-01-box.html#enabling-recursive-types-with-boxes">Heap: Using Box<T> to Point to Data on the Heap - The Rust Programming Language</a></p>
</blockquote>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<p>Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons “list builder”.
Although the current list is one of integers (i32), feel free to change the definition
and try other types!</p>
</div>
</details>
<details id="admonition-solution-boxnew" class="admonition success">
<summary class="admonition-title">
<p>solution: Box::new()</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-solution-boxnew"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">#[derive(PartialEq, Debug)]
pub enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

pub fn create_empty_list() -&gt; List {
    List::Nil
}

pub fn create_non_empty_list() -&gt; List {
    List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))))
}
</code></pre></pre>
</div>
</details>
<h3 id="cow-clone-on-write"><a class="header" href="#cow-clone-on-write">Cow: Clone-On-Write</a></h3>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_1_2_cow.html">Cow&lt;’a, B&gt; - Anatomy In First Rust Programming Class 🦀</a></li>
</ul>
<blockquote>
<p>This exercise explores the Cow, or Clone-On-Write type.</p>
</blockquote>
<ul>
<li>Cow is a clone-on-write smart pointer.</li>
<li>It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.</li>
<li>The type is designed to work with general borrowed data via the Borrow trait.</li>
</ul>
<blockquote>
<p>This exercise is meant to show you what to expect when passing data to Cow.</p>
</blockquote>
<details id="admonition-cow1" class="admonition note">
<summary class="admonition-title">
<p>cow1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-cow1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.
//
// This exercise is meant to show you what to expect when passing data to Cow.
// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the TODO markers.

// I AM NOT DONE

use std::borrow::Cow;

fn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

// convert unit tests to main
fn main() {
    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // No clone occurs because `input` doesn't need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
    reference_mutation();
    reference_no_mutation();
    owned_no_mutation();
    owned_mutation();
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Clone occurs because `input` needs to be mutated.
        let slice = [-1, 0, 1];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            Cow::Owned(_) =&gt; Ok(()),
            _ =&gt; Err(&quot;Expected owned value&quot;),
        }
    }

    #[test]
    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // No clone occurs because `input` doesn't need to be mutated.
        let slice = [0, 1, 2];
        let mut input = Cow::from(&amp;slice[..]);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // We can also pass `slice` without `&amp;` so Cow owns it directly.
        // In this case no mutation occurs and thus also no clone,
        // but the result is still owned because it always was.
        let slice = vec![0, 1, 2];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }

    #[test]
    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {
        // Of course this is also the case if a mutation does occur.
        // In this case the call to `to_mut()` returns a reference to
        // the same data as before.
        let slice = vec![-1, 0, 1];
        let mut input = Cow::from(slice);
        match abs_all(&amp;mut input) {
            // TODO
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>Since the vector is already owned, the <code>Cow</code> type doesn’t need to clone it.</p>
<p>Checkout <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">Cow in std::borrow - Rust</a> for documentation
on the <code>Cow</code> type.</p>
</div>
</details>
<details id="admonition-solution-cowborrowed_cowowned_" class="admonition success">
<summary class="admonition-title">
<p>solution: Cow::Borrowed(<em>)/Cow::Owned(</em>)</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-solution-cowborrowed_cowowned_"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// cow1.rs

// This exercise explores the Cow, or Clone-On-Write type.
// Cow is a clone-on-write smart pointer.
// It can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required.
// The type is designed to work with general borrowed data via the Borrow trait.

use std::borrow::Cow;

fn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // Clones into a vector if not already owned.
            input.to_mut()[i] = -v;
        }
    }
    input
}

fn main() {
    // No clone occurs because `input` doesn't need to be mutated.
    let slice = [0, 1, 2];
    let mut input = Cow::from(&amp;slice[..]);
    match abs_all(&amp;mut input) {
        Cow::Borrowed(_) =&gt; println!(&quot;I borrowed the slice!&quot;),
        _ =&gt; panic!(&quot;expected borrowed value&quot;),
    }

    // Clone occurs because `input` needs to be mutated.
    let slice = [-1, 0, 1];
    let mut input = Cow::from(&amp;slice[..]);
    match abs_all(&amp;mut input) {
        Cow::Owned(_) =&gt; println!(&quot;I modified the slice and now own it!&quot;),
        _ =&gt; panic!(&quot;expected owned value&quot;),
    }

    // No clone occurs because `input` is already owned.
    let slice = vec![-1, 0, 1];
    let mut input = Cow::from(slice);
    match abs_all(&amp;mut input) {
        Cow::Owned(_) =&gt; println!(&quot;I own this slice!&quot;),
        _ =&gt; panic!(&quot;expected borrowed value&quot;),
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="rc"><a class="header" href="#rc">Rc</a></h3>
<blockquote>
<p>In this exercise, we want to express the concept of multiple owners via the Rc<T> type.</p>
</blockquote>
<ul>
<li>This is a model of our solar system - there is a Sun type and multiple Planets.</li>
<li>The Planets take ownership of the sun, indicating that they revolve around the sun.</li>
</ul>
<blockquote>
<p>Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.</p>
</blockquote>
<details id="admonition-rc1" class="admonition note">
<summary class="admonition-title">
<p>rc1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-rc1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// rc1.rs
// In this exercise, we want to express the concept of multiple owners via the Rc&lt;T&gt; type.
// This is a model of our solar system - there is a Sun type and multiple Planets.
// The Planets take ownership of the sun, indicating that they revolve around the sun.

// Make this code compile by using the proper Rc primitives to express that the sun has multiple owners.

// I AM NOT DONE

use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    // TODO
    let saturn = Planet::Saturn(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    // TODO
    let uranus = Planet::Uranus(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    // TODO
    let neptune = Planet::Neptune(Rc::new(Sun {}));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    // TODO
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-hint-3"></a></p>
</summary>
<div>
<p>This is a straightforward exercise to use the Rc<T> type:</p>
<ul>
<li>Each Planet has ownership of the Sun, and uses Rc::clone() to increment the reference count of the Sun.</li>
<li>After using drop() to move the Planets out of scope individually, the reference count goes down.</li>
<li>In the end the sun only has one reference again, to itself. </li>
</ul>
<blockquote>
<p>See more at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch15-04-rc.html">Rc<T>(Reference Counting): single-threaded scenarios, immutable references of multiple owners, the Reference Counted Smart Pointer - The Rust Programming Language</a></p>
</blockquote>
<ul>
<li>Unfortunately Pluto is no longer considered a planet :(</li>
</ul>
</div>
</details>
<details id="admonition-solution-arcnew-1" class="admonition success">
<summary class="admonition-title">
<p>solution: Arc::new()</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-solution-arcnew-1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

#[derive(Debug)]
struct Sun {}

#[derive(Debug)]
enum Planet {
    Mercury(Rc&lt;Sun&gt;),
    Venus(Rc&lt;Sun&gt;),
    Earth(Rc&lt;Sun&gt;),
    Mars(Rc&lt;Sun&gt;),
    Jupiter(Rc&lt;Sun&gt;),
    Saturn(Rc&lt;Sun&gt;),
    Uranus(Rc&lt;Sun&gt;),
    Neptune(Rc&lt;Sun&gt;),
}

impl Planet {
    fn details(&amp;self) {
        println!(&quot;Hi from {:?}!&quot;, self)
    }
}

fn main() {
    let sun = Rc::new(Sun {});
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    let mercury = Planet::Mercury(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references
    mercury.details();

    let venus = Planet::Venus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references
    venus.details();

    let earth = Planet::Earth(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references
    earth.details();

    let mars = Planet::Mars(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references
    mars.details();

    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references
    jupiter.details();

    let saturn = Planet::Saturn(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references
    saturn.details();

    let uranus = Planet::Uranus(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references
    uranus.details();

    let neptune = Planet::Neptune(Rc::clone(&amp;sun));
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 9 references
    neptune.details();

    assert_eq!(Rc::strong_count(&amp;sun), 9);

    drop(neptune);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 8 references

    drop(uranus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 7 references

    drop(saturn);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 6 references

    drop(jupiter);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 5 references

    drop(mars);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 4 references

    drop(earth);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 3 references

    drop(venus);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 2 references

    drop(mercury);
    println!(&quot;reference count = {}&quot;, Rc::strong_count(&amp;sun)); // 1 reference

    assert_eq!(Rc::strong_count(&amp;sun), 1);
}
</code></pre></pre>
</div>
</details>
<h3 id="memory-leak"><a class="header" href="#memory-leak">Memory Leak</a></h3>
<details id="admonition-memory_leak1" class="admonition note">
<summary class="admonition-title">
<p>memory_leak1</p>
<p><a class="admonition-anchor-link" href="smart_pointers/smart_pointer.html#admonition-memory_leak1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

struct Node {
    value: i32,
    parent: Option&lt;Rc&lt;Node&gt;&gt;,
    children: Vec&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    fn new(value: i32) -&gt; Rc&lt;Self&gt; {
        Rc::new(Self {
            value,
            parent: None,
            children: Vec::new(),
        })
    }

    fn add_child(&amp;mut self, child: Rc&lt;Self&gt;) {
        self.children.push(child);
        child.parent = Some(Rc::clone(&amp;self));
    }
}

fn main() {
    let root = Node::new(0);
    let child1 = Node::new(1);
    let child2 = Node::new(2);
    child1.add_child(Rc::clone(&amp;child2));
    child2.add_child(Rc::clone(&amp;child1));
    root.add_child(child1);
    root.add_child(child2);
    println!(&quot;{}&quot;, root.value);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<!--ts-->
<ul>
<li><a href="conversions/conversions.html#type-conversions">Type conversions</a>
<ul>
<li><a href="conversions/conversions.html#further-information">Further information</a></li>
<li><a href="conversions/conversions.html#rustlings">Rustlings</a>
<ul>
<li><a href="conversions/conversions.html#using-as-type-casting">using as: type casting</a></li>
<li><a href="conversions/conversions.html#from_into-value-to-value">from_into: value-to-value</a></li>
<li><a href="conversions/conversions.html#try_from_into-try-value-to-value">try_from_into: try value-to-value</a></li>
<li><a href="conversions/conversions.html#as_ref_mut-reference-to-reference">as_ref_mut: reference-to-reference</a></li>
<li><a href="conversions/conversions.html#from_str-convert-str-to-target-type">from_str: convert str to target type</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Thu Mar 16 14:35:07 UTC 2023 -->
<!--te-->
<blockquote>
<p>Rust offers a multitude of ways to convert a value of a given type into another type.</p>
</blockquote>
<ol>
<li>as: The simplest form of type conversion is a type cast expression.</li>
</ol>
<blockquote>
<p>It is denoted with the binary operator <code>as</code>.</p>
</blockquote>
<p>For instance, <code>println!(&quot;{}&quot;, 1 + 1.0);</code> would not compile, since <code>1</code> is an integer while <code>1.0</code> is a float. However, <code>println!(&quot;{}&quot;, 1 as f32 + 1.0)</code> should compile. The
exercise <a href="conversions/conversions.html#using-as-type-casting"><code>using_as</code></a> tries to cover this.</p>
<ol start="2">
<li>from/into/AsRef: Rust also offers traits that <code>facilitate type conversions</code> upon implementation.</li>
</ol>
<blockquote>
<p>These traits can be found under the <a href="https://doc.rust-lang.org/std/convert/index.html"><code>convert</code></a> module.</p>
</blockquote>
<p>The traits are the following:</p>
<ul>
<li><code>From</code> and <code>Into</code> covered in <a href="conversions/conversions.html#from_into-value-to-value"><code>from_into</code></a></li>
<li><code>TryFrom</code> and <code>TryInto</code> covered in <a href="conversions/conversions.html#try_from_into-try-value-to-value"><code>try_from_into</code></a></li>
<li><code>AsRef</code> and <code>AsMut</code> covered in <a href="conversions/conversions.html#as_ref_mut-reference-to-reference"><code>as_ref_mut</code></a></li>
</ul>
<ol start="3">
<li>from_str: Furthermore, the <code>std::str</code> module offers a trait called <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> which helps with converting strings into target types via the <code>parse</code> method on strings.</li>
</ol>
<blockquote>
<p>If properly implemented for a given type <code>Person</code>,
then <code>let p: Person = &quot;Mark,20&quot;.parse().unwrap()</code> should both compile and run without panicking.</p>
</blockquote>
<p>These should be the main ways <em><strong>within the standard library</strong></em> to convert data into your desired types.</p>
<ul>
<li>solutions: <a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/conversions">rustlings-solutions-5/conversions at main · gaveen/rustlings-solutions-5</a></li>
</ul>
<h2 id="further-information-9"><a class="header" href="#further-information-9">Further information</a></h2>
<p>These are not directly covered in the book, but the standard library has a great documentation for it.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/index.html">conversions</a></li>
<li><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code> trait</a></li>
</ul>
<h2 id="rustlings-8"><a class="header" href="#rustlings-8">Rustlings</a></h2>
<h3 id="using-as-type-casting"><a class="header" href="#using-as-type-casting">using <code>as</code>: type casting</a></h3>
<ul>
<li>Type casting in Rust is done via the usage of the <code>as</code> operator.</li>
<li>Please note that the <code>as</code> operator is not only used when type casting.</li>
<li>It also helps with renaming imports.</li>
</ul>
<blockquote>
<p>The goal is to make sure that the division does not fail to compile
and returns the proper type.</p>
</blockquote>
<details id="admonition-using_as" class="admonition note">
<summary class="admonition-title">
<p>using_as</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-using_as"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Type casting in Rust is done via the usage of the `as` operator.
// Please note that the `as` operator is not only used when type casting.
// It also helps with renaming imports.
//
// The goal is to make sure that the division does not fail to compile
// and returns the proper type.
// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total / values.len()
}

fn main() {
    let values = [3.5, 0.3, 13.0, 11.7];
    println!(&quot;{}&quot;, average(&amp;values));
    // convert unit tests to here to run in the rust playground
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
    returns_proper_type_and_value();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_proper_type_and_value() {
        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-hint"></a></p>
</summary>
<div>
<p>Use the <code>as</code> operator to cast one of the operands in the last line of the
<code>average</code> function into the expected return type.</p>
</div>
</details>
<details id="admonition-solution" class="admonition success">
<summary class="admonition-title">
<p>solution</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn average(values: &amp;[f64]) -&gt; f64 {
    let total = values.iter().sum::&lt;f64&gt;();
    total / values.len() as f64
}
</code></pre></pre>
</div>
</details>
<h3 id="from_into-value-to-value"><a class="header" href="#from_into-value-to-value">from_into: value-to-value</a></h3>
<ul>
<li>The From trait is used for <code>value-to-value</code> conversions.</li>
</ul>
<blockquote>
<p>If From is implemented correctly for a type, the Into trait should work conversely.</p>
</blockquote>
<ul>
<li>You can read more about it at: <a href="https://doc.rust-lang.org/std/convert/trait.From.html">From in std::convert - Rust</a></li>
</ul>
<blockquote>
<p>Your task is:</p>
</blockquote>
<ul>
<li>to complete this implementation in order for the line <code>let p = Person::from(&quot;Mark,20&quot;)</code> to compile</li>
<li>Please note that you’ll need to parse the age component into a <code>usize</code> with something like <code>&quot;4&quot;.parse::&lt;usize&gt;()</code>.</li>
<li>The outcome of this needs to be handled appropriately.</li>
</ul>
<blockquote>
<p>Steps:</p>
</blockquote>
<ol>
<li>If the length of the provided string is 0, then return the default of Person</li>
<li>Split the given string on the commas present in it</li>
<li>Extract the first element from the split operation and use it as the name</li>
<li>If the name is empty, then return the default of Person</li>
<li>Extract the other element from the split operation and parse it into a <code>usize</code> as the age</li>
<li>If while parsing the age, something goes wrong, then return the default of Person</li>
<li>Otherwise, then return an instantiated Person object with the results</li>
</ol>
<details id="admonition-from_into-we-implement-the-default-trait-to-use-it-as-a-fallback-when-the-provided-string-is-not-convertible-into-a-person-object" class="admonition note">
<summary class="admonition-title">
<p>🌟from_into: We implement the Default trait to use it as a fallback when the provided string is not convertible into a Person object</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-from_into-we-implement-the-default-trait-to-use-it-as-a-fallback-when-the-provided-string-is-not-convertible-into-a-person-object"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// The From trait is used for value-to-value conversions.
// If From is implemented correctly for a type, the Into trait should work conversely.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.From.html
// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a hint.

#[derive(Debug)]
struct Person {
    name: String,
    age: usize,
}

// We implement the Default trait to use it as a fallback
// when the provided string is not convertible into a Person object
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: String::from(&quot;John&quot;),
            age: 30,
        }
    }
}

// Your task is to complete this implementation
// in order for the line `let p = Person::from(&quot;Mark,20&quot;)` to compile
// Please note that you'll need to parse the age component into a `usize`
// with something like `&quot;4&quot;.parse::&lt;usize&gt;()`. The outcome of this needs to
// be handled appropriately.
//
// Steps:
// 1. If the length of the provided string is 0, then return the default of Person
// 2. Split the given string on the commas present in it
// 3. Extract the first element from the split operation and use it as the name
// 4. If the name is empty, then return the default of Person
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
// If while parsing the age, something goes wrong, then return the default of Person
// Otherwise, then return an instantiated Person object with the results

// I AM NOT DONE

impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person {}
}

fn main() {
    // Use the `from` function
    let p1 = Person::from(&quot;Mark,20&quot;);
    // Since From is implemented for Person, we should be able to use Into
    let p2: Person = &quot;Gerald,70&quot;.into();
    println!(&quot;{:?}&quot;, p1);
    println!(&quot;{:?}&quot;, p2);
    // convert unit tests to here to run in the rust playground
    // Test that the default person is 30 year old John
    let dp = Person::default();
    assert_eq!(dp.name, &quot;John&quot;);
    assert_eq!(dp.age, 30);
    // Test that John is returned when bad string is provided
    let p = Person::from(&quot;&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);
    // Test that &quot;Mark,20&quot; works
    let p = Person::from(&quot;Mark,20&quot;);
    assert_eq!(p.name, &quot;Mark&quot;);
    assert_eq!(p.age, 20);
    // Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age
    let p = Person::from(&quot;Mark,twenty&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;Mark&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;Mark,&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;,1&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;,&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;,one&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;Mike,32,&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);

    let p: Person = Person::from(&quot;Mike,32,man&quot;);
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 30);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default() {
        // Test that the default person is 30 year old John
        let dp = Person::default();
        assert_eq!(dp.name, &quot;John&quot;);
        assert_eq!(dp.age, 30);
    }

    #[test]
    fn test_bad_convert() {
        // Test that John is returned when bad string is provided
        let p = Person::from(&quot;&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_good_convert() {
        // Test that &quot;Mark,20&quot; works
        let p = Person::from(&quot;Mark,20&quot;);
        assert_eq!(p.name, &quot;Mark&quot;);
        assert_eq!(p.age, 20);
    }

    #[test]
    fn test_bad_age() {
        // Test that &quot;Mark,twenty&quot; will return the default person due to an error in parsing age
        let p = Person::from(&quot;Mark,twenty&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_comma_and_age() {
        let p: Person = Person::from(&quot;Mark&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_age() {
        let p: Person = Person::from(&quot;Mark,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name() {
        let p: Person = Person::from(&quot;,1&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_age() {
        let p: Person = Person::from(&quot;,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_missing_name_and_invalid_age() {
        let p: Person = Person::from(&quot;,one&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma() {
        let p: Person = Person::from(&quot;Mike,32,&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }

    #[test]
    fn test_trailing_comma_and_some_string() {
        let p: Person = Person::from(&quot;Mike,32,man&quot;);
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 30);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Follow the steps provided right before the <code>From</code> implementation</p>
</div>
</details>
<details id="admonition-solution-match---split_once---parse---into-or-default" class="admonition success">
<summary class="admonition-title">
<p>solution: match -&gt; split_once -&gt; parse::<usize> -&gt; into() or default()</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution-match---split_once---parse---into-or-default"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">impl From&lt;&amp;str&gt; for Person {
    fn from(s: &amp;str) -&gt; Person { // 2. Split the given string on the commas present in it
        match s.split_once(',') {
            Some((first, second)) =&gt; {
                if first.is_empty() { // 4. If the name is empty, then return the default of Person
                    Person::default()
                } else if let Ok(a) = second.parse::&lt;usize&gt;() { // 5. Extract the other element from the split operation and parse it into a `usize` as the age
                    Person {
                        name: first.into(), // 3. Extract the first element from the split operation and use it as the name
                        age: a, // 6. If while parsing the age, something goes wrong, then return the default of Person 
                    }
                } else {
                    Person::default() // 7. Otherwise, then return an instantiated Person object with the results
                }
            },
            _ =&gt; Person::default(), // 1. If the length of the provided string is 0, then return the default of Person
        }
    }
}
</code></pre></pre>
</div>
</details>
<h3 id="try_from_into-try-value-to-value"><a class="header" href="#try_from_into-try-value-to-value">try_from_into: try value-to-value</a></h3>
<ul>
<li>TryFrom is a simple and safe type conversion that may fail in <code>a controlled way</code> under some circumstances.</li>
<li>Basically, this is the same as From.</li>
</ul>
<blockquote>
<p>The main difference is that this should return a Result type instead of the target type itself.</p>
</blockquote>
<ul>
<li>You can read more about it at: <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom in std::convert - Rust</a></li>
</ul>
<blockquote>
<p>Your task is to complete this implementation:</p>
</blockquote>
<ol>
<li>return an Ok result of inner type Color.</li>
<li>You need to create an implementation for a <code>tuple</code> of three integers, an <code>array</code> of three integers, and a <code>slice</code> of integers.</li>
<li>Note that the implementation for tuple and array will be checked at compile time, but the slice implementation needs to check the slice length!</li>
<li>Also note that correct RGB color values must be integers in the 0..=255 range.</li>
</ol>
<details id="admonition-try_from_into-with-challenge" class="admonition note">
<summary class="admonition-title">
<p>⚡️try_from_into: with challenge</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-try_from_into-with-challenge"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// try_from_into.rs
// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.
// Basically, this is the same as From. The main difference is that this should return a Result type
// instead of the target type itself.
// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html
// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.

use std::convert::{TryFrom, TryInto};

#[derive(Debug, PartialEq)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// We will use this error type for these `TryFrom` conversions.
#[derive(Debug, PartialEq)]
enum IntoColorError {
    // Incorrect length of slice
    BadLen,
    // Integer conversion error
    IntConversion,
}

// I AM NOT DONE

// Your task is to complete this implementation
// and return an Ok result of inner type Color.
// You need to create an implementation for a tuple of three integers,
// an array of three integers, and a slice of integers.
//
// Note that the implementation for tuple and array will be checked at compile time,
// but the slice implementation needs to check the slice length!
// Also note that correct RGB color values must be integers in the 0..=255 range.

// Tuple implementation
impl TryFrom&lt;(i16, i16, i16)&gt; for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Array implementation
impl TryFrom&lt;[i16; 3]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

// Slice implementation
impl TryFrom&lt;&amp;[i16]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(slice: &amp;[i16]) -&gt; Result&lt;Self, Self::Error&gt; {
    }
}

fn main() {
    // Use the `try_from` function
    let c1 = Color::try_from((183, 65, 14));
    println!(&quot;{:?}&quot;, c1);

    // Since TryFrom is implemented for Color, we should be able to use TryInto
    let c2: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
    println!(&quot;{:?}&quot;, c2);

    let v = vec![183, 65, 14];
    // With slice we should use `try_from` function
    let c3 = Color::try_from(&amp;v[..]);
    println!(&quot;{:?}&quot;, c3);
    // or take slice within round brackets and use TryInto
    let c4: Result&lt;Color, _&gt; = (&amp;v[..]).try_into();
    println!(&quot;{:?}&quot;, c4);
    // convert unit tests to here to run in the rust playground
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_tuple_correct() {
        let c: Result&lt;Color, _&gt; = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    fn test_array_out_of_range_positive() {
        let c: Result&lt;Color, _&gt; = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    fn test_array_out_of_range_negative() {
        let c: Result&lt;Color, _&gt; = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    fn test_array_sum() {
        let c: Result&lt;Color, _&gt; = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    fn test_array_correct() {
        let c: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result&lt;Color, _&gt; = Color::try_from(&amp;v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
    test_tuple_out_of_range_positive();
    test_tuple_out_of_range_negative();
    test_tuple_sum();
    test_tuple_correct();
    test_array_out_of_range_positive();
    test_array_out_of_range_negative();
    test_array_sum();
    test_array_correct();
    test_slice_out_of_range_positive();
    test_slice_out_of_range_negative();
    test_slice_sum();
    test_slice_correct();
    test_slice_excess_length();
    test_slice_insufficient_length();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tuple_out_of_range_positive() {
        assert_eq!(
            Color::try_from((256, 1000, 10000)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_out_of_range_negative() {
        assert_eq!(
            Color::try_from((-1, -10, -256)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_sum() {
        assert_eq!(
            Color::try_from((-1, 255, 255)),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_tuple_correct() {
        let c: Result&lt;Color, _&gt; = (183, 65, 14).try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_array_out_of_range_positive() {
        let c: Result&lt;Color, _&gt; = [1000, 10000, 256].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_out_of_range_negative() {
        let c: Result&lt;Color, _&gt; = [-10, -256, -1].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_sum() {
        let c: Result&lt;Color, _&gt; = [-1, 255, 255].try_into();
        assert_eq!(c, Err(IntoColorError::IntConversion));
    }
    #[test]
    fn test_array_correct() {
        let c: Result&lt;Color, _&gt; = [183, 65, 14].try_into();
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_out_of_range_positive() {
        let arr = [10000, 256, 1000];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_out_of_range_negative() {
        let arr = [-256, -1, -10];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_sum() {
        let arr = [-1, 255, 255];
        assert_eq!(
            Color::try_from(&amp;arr[..]),
            Err(IntoColorError::IntConversion)
        );
    }
    #[test]
    fn test_slice_correct() {
        let v = vec![183, 65, 14];
        let c: Result&lt;Color, _&gt; = Color::try_from(&amp;v[..]);
        assert!(c.is_ok());
        assert_eq!(
            c.unwrap(),
            Color {
                red: 183,
                green: 65,
                blue: 14
            }
        );
    }
    #[test]
    fn test_slice_excess_length() {
        let v = vec![0, 0, 0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
    #[test]
    fn test_slice_insufficient_length() {
        let v = vec![0, 0];
        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-hint-2"></a></p>
</summary>
<div>
<ol>
<li>Follow the steps provided right before the <code>TryFrom</code> implementation.
You can also use the example at: <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">TryFrom in std::convert - Rust</a></li>
</ol>
<p>Is there an implementation of <code>TryFrom</code> in the standard library that
can both do the required integer conversion and check the range of the input?</p>
<ol start="2">
<li>
<p>Another hint: Look at the test cases to see which error variants to return.</p>
</li>
<li>
<p>Yet another hint: You can use the <code>map_err</code> or <code>or</code> methods of <code>Result</code> to
convert errors.</p>
</li>
<li>
<p>Yet another hint: If you would like to propagate errors by using the <code>?</code>
operator in your solution, you might want to look at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/multiple_error_types/reenter_question_mark.html">Other uses of ? - The Rust Programming Language</a></p>
</li>
</ol>
</div>
</details>
<details id="admonition-solution-essentially-return-to-run-the-implementation-of-tuple" class="admonition success">
<summary class="admonition-title">
<p>solution: essentially return to run the implementation of tuple</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution-essentially-return-to-run-the-implementation-of-tuple"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Tuple implementation
impl TryFrom&lt;(i16, i16, i16)&gt; for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -&gt; Result&lt;Self, Self::Error&gt; {
        for i in [tuple.0, tuple.1, tuple.2] {
            if i &lt; 0 || i &gt; 255 {
                return Err(IntoColorError::IntConversion)
            }
        }
        // return an Ok result of inner type Color.
        Ok(Color { red: tuple.0 as u8, green: tuple.1 as u8, blue: tuple.2 as u8 })
    }
}

// Array implementation
impl TryFrom&lt;[i16; 3]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(arr: [i16; 3]) -&gt; Result&lt;Self, Self::Error&gt; {
        // return to run the implementation of tuple above
        Self::try_from((arr[0], arr[1], arr[2]))
    }
}

// Slice implementation
impl TryFrom&lt;&amp;[i16]&gt; for Color {
    type Error = IntoColorError;
    fn try_from(slice: &amp;[i16]) -&gt; Result&lt;Self, Self::Error&gt; {
        if slice.len() != 3 {
            Err(IntoColorError::BadLen)
        } else {
            // return to run the implementation of tuple above
            Self::try_from((slice[0], slice[1], slice[2]))
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-challenge" class="admonition danger">
<summary class="admonition-title">
<p>challenge!</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-challenge"></a></p>
</summary>
<div>
<p>Challenge: Can you make the <code>TryFrom</code> implementations generic over many integer types?</p>
</div>
</details>
<h3 id="as_ref_mut-reference-to-reference"><a class="header" href="#as_ref_mut-reference-to-reference">as_ref_mut: reference-to-reference</a></h3>
<blockquote>
<p><code>AsRef</code> and <code>AsMut</code> allow for cheap reference-to-reference conversions.</p>
</blockquote>
<p>Read more about them at <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html">AsRef in std::convert - Rust</a>
and <a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html">AsMut in std::convert - Rust</a>, respectively.</p>
<details id="admonition-as_ref_mut-three-ways-to-add-appropriate-trait-bound" class="admonition note">
<summary class="admonition-title">
<p>as_ref_mut: Three ways to add appropriate trait bound</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-as_ref_mut-three-ways-to-add-appropriate-trait-bound"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// AsRef and AsMut allow for cheap reference-to-reference conversions.
// Read more about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html
// and https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.
// Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// Obtain the number of bytes (not characters) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn byte_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument.
// TODO: Add the AsRef trait appropriately as a trait bound.
fn char_counter&lt;T&gt;(arg: T) -&gt; usize {
    arg.as_ref().chars().count()
}

// Squares a number using as_mut().
// TODO: Add the appropriate trait bound.
fn num_sq&lt;T&gt;(arg: &amp;mut T) {
    // TODO: Implement the function body.
    ? ? ?
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn different_counts() {
        let s = &quot;Café au lait&quot;;
        assert_ne!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn same_counts() {
        let s = &quot;Cafe au lait&quot;;
        assert_eq!(char_counter(s), byte_counter(s));
    }

    #[test]
    fn different_counts_using_string() {
        let s = String::from(&quot;Café au lait&quot;);
        assert_ne!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn same_counts_using_string() {
        let s = String::from(&quot;Cafe au lait&quot;);
        assert_eq!(char_counter(s.clone()), byte_counter(s));
    }

    #[test]
    fn mult_box() {
        let mut num: Box&lt;u32&gt; = Box::new(3);
        num_sq(&amp;mut num);
        assert_eq!(*num, 9);
    }
}

// convert the unit test to main
fn main() {
    // different_counts()
    let s = &quot;Café au lait&quot;;
    assert_ne!(char_counter(s), byte_counter(s));
    // same_counts
    let s = &quot;Cafe au lait&quot;;
    assert_eq!(char_counter(s), byte_counter(s));
    // different_counts_using_string
    let s = String::from(&quot;Café au lait&quot;);
    assert_ne!(char_counter(s.clone()), byte_counter(s));
    // same_counts_using_string
    let s = String::from(&quot;Cafe au lait&quot;);
    assert_eq!(char_counter(s.clone()), byte_counter(s));
    // mult_box
    let mut num: Box&lt;u32&gt; = Box::new(3);
    num_sq(&amp;mut num);
    assert_eq!(*num, 9);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-hint-3"></a></p>
</summary>
<div>
<p>Add AsRef<str> as a trait bound to the functions.</p>
</div>
</details>
<blockquote>
<p>compare to <a href="https://kuanhsiaokuo.github.io/the-rustlings-collection/traits/traits.html">traits4</a></p>
</blockquote>
<details id="admonition-solution1-generic-trait-bounds" class="admonition success">
<summary class="admonition-title">
<p>solution1: generic trait bounds</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution1-generic-trait-bounds"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Obtain the number of bytes (not characters) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn byte_counter&lt;T: AsRef&lt;str&gt;&gt;(arg: T) -&gt; usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn char_counter&lt;T: AsRef&lt;str&gt;&gt;(arg: T) -&gt; usize {
    arg.as_ref().chars().count()
}

// Squares a number using AsMut. Add the trait bound as is appropriate and
// implement the function body.
fn num_sq&lt;T: AsMut&lt;u32&gt;&gt;(arg: &amp;mut T) {
    *arg.as_mut() *= *arg.as_mut()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-impl-trait-bounds" class="admonition success">
<summary class="admonition-title">
<p>solution2: impl trait bounds</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution2-impl-trait-bounds"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Obtain the number of bytes (not characters) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn byte_counter(arg: impl AsRef&lt;str&gt;) -&gt; usize {
    arg.as_ref().as_bytes().len()
}

// Obtain the number of characters (not bytes) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn char_counterd(arg: impl AsRef&lt;str&gt;) -&gt; usize {
    arg.as_ref().chars().count()
}

// Squares a number using AsMut. Add the trait bound as is appropriate and
// implement the function body.
fn num_sq(arg: &amp;mut impl AsRef&lt;str&gt;) {
    *arg.as_mut() *= *arg.as_mut()
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution3-where-clause" class="admonition success">
<summary class="admonition-title">
<p>solution3: where clause</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution3-where-clause"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Obtain the number of bytes (not characters) in the given argument
// Add the AsRef trait appropriately as a trait bound
fn byte_counter&lt;T&gt;(arg: T) -&gt; usize
where T: AsRef&lt;str&gt;
{
    arg.as_ref().as_bytes().len()
}
</code></pre></pre>
</div>
</details>
<h3 id="from_str-convert-str-to-target-type"><a class="header" href="#from_str-convert-str-to-target-type">from_str: convert str to target type</a></h3>
<ul>
<li>This is similar to from_into.rs, but this time we’ll implement <code>FromStr</code> and return errors instead of falling back to a default value.</li>
<li>Additionally, upon implementing FromStr, you can use the <code>parse</code> method on strings to generate an object of the implementor type.</li>
<li>You can read more about it at <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr in std::str - Rust</a></li>
</ul>
<blockquote>
<p>Steps:</p>
</blockquote>
<ol>
<li>If the length of the provided string is 0, an error should be returned</li>
<li>Split the given string on the commas present in it</li>
<li>Only 2 elements should be returned from the split, otherwise return an error</li>
<li>Extract the first element from the split operation and use it as the name</li>
<li>Extract the other element from the split operation and parse it into a <code>usize</code> as the age
with something like <code>&quot;4&quot;.parse::&lt;usize&gt;()</code></li>
<li>If while extracting the name and the age something goes wrong, an error should be returned</li>
<li>If everything goes well, then return a Result of a Person object</li>
</ol>
<p>As an aside: <code>Box&lt;dyn Error&gt;</code> implements <code>From&lt;&amp;'_ str&gt;</code>. This means that if you want to return a
string error message, you can do so via just using return <code>Err(&quot;my error message&quot;.into())</code>.</p>
<details id="admonition-from_str" class="admonition note">
<summary class="admonition-title">
<p>from_str</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-from_str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// from_str.rs
// This is similar to from_into.rs, but this time we'll implement `FromStr`
// and return errors instead of falling back to a default value.
// Additionally, upon implementing FromStr, you can use the `parse` method
// on strings to generate an object of the implementor type.
// You can read more about it at https://doc.rust-lang.org/std/str/trait.FromStr.html
// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a hint.

use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct Person {
    name: String,
    age: usize,
}

// We will use this error type for the `FromStr` implementation.
#[derive(Debug, PartialEq)]
enum ParsePersonError {
    // Empty input string
    Empty,
    // Incorrect number of fields
    BadLen,
    // Empty name field
    NoName,
    // Wrapped error from parse::&lt;usize&gt;()
    ParseInt(ParseIntError),
}

// I AM NOT DONE

// Steps:
// 1. If the length of the provided string is 0, an error should be returned
// 2. Split the given string on the commas present in it
// 3. Only 2 elements should be returned from the split, otherwise return an error
// 4. Extract the first element from the split operation and use it as the name
// 5. Extract the other element from the split operation and parse it into a `usize` as the age
//    with something like `&quot;4&quot;.parse::&lt;usize&gt;()`
// 6. If while extracting the name and the age something goes wrong, an error should be returned
// If everything goes well, then return a Result of a Person object
//
// As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;'_ str&gt;`. This means that if you want to return a
// string error message, you can do so via just using return `Err(&quot;my error message&quot;.into())`.

impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {}
}

fn main() {
    let p = &quot;Mark,20&quot;.parse::&lt;Person&gt;().unwrap();
    println!(&quot;{:?}&quot;, p);
    // convert unit tests to here to run in the rust playground
    assert_eq!(&quot;&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));
    let p = &quot;John,32&quot;.parse::&lt;Person&gt;();
    assert!(p.is_ok());
    let p = p.unwrap();
    assert_eq!(p.name, &quot;John&quot;);
    assert_eq!(p.age, 32);
    assert!(matches!(
            &quot;John,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));

    assert!(matches!(
            &quot;John,twenty&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));

    assert_eq!(&quot;John&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));

    assert_eq!(&quot;,1&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));

    assert!(matches!(
            &quot;,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));

    assert!(matches!(
            &quot;,one&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));

    assert_eq!(&quot;John,32,&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));

    assert_eq!(
        &quot;John,32,man&quot;.parse::&lt;Person&gt;(),
        Err(ParsePersonError::BadLen)
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        assert_eq!(&quot;&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));
    }

    #[test]
    fn good_input() {
        let p = &quot;John,32&quot;.parse::&lt;Person&gt;();
        assert!(p.is_ok());
        let p = p.unwrap();
        assert_eq!(p.name, &quot;John&quot;);
        assert_eq!(p.age, 32);
    }

    #[test]
    fn missing_age() {
        assert!(matches!(
            &quot;John,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn invalid_age() {
        assert!(matches!(
            &quot;John,twenty&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_comma_and_age() {
        assert_eq!(&quot;John&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn missing_name() {
        assert_eq!(&quot;,1&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));
    }

    #[test]
    fn missing_name_and_age() {
        assert!(matches!(
            &quot;,&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn missing_name_and_invalid_age() {
        assert!(matches!(
            &quot;,one&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))
        ));
    }

    #[test]
    fn trailing_comma() {
        assert_eq!(&quot;John,32,&quot;.parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));
    }

    #[test]
    fn trailing_comma_and_some_string() {
        assert_eq!(
            &quot;John,32,man&quot;.parse::&lt;Person&gt;(),
            Err(ParsePersonError::BadLen)
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-4" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-hint-4"></a></p>
</summary>
<div>
<ol>
<li>The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.</li>
</ol>
<p>This is almost like the <code>from_into</code> exercise, but returning errors instead
of falling back to a default value.</p>
<p>Look at the test cases to see which error variants to return.</p>
<ol start="2">
<li>
<p>Another hint: You can use the <code>map_err</code> method of <code>Result</code> with a function
or a closure to wrap the error from <code>parse::&lt;usize&gt;</code>.</p>
</li>
<li>
<p>Yet another hint: If you would like to propagate errors by using the <code>?</code>
operator in your solution, you might want to look at
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/multiple_error_types/reenter_question_mark.html">Other uses of ? - The Rust Programming Language</a></p>
</li>
</ol>
</div>
</details>
<details id="admonition-solution1" class="admonition failure">
<summary class="admonition-title">
<p>solution1</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Using ParsePersonError::{Empty, BadLen, NoName, ParseInt} above
impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
        if s.is_empty() {
            Err(Empty) // i.e., Err(ParsePersonError::Empty)
        } else {
            let p: Vec&lt;&amp;str&gt; = s.split(',').collect();
            if p.len() != 2 {
                Err(BadLen)
            } else if p[0].len() == 0 {
                Err(NoName)
            } else { 
                match p[1].parse::&lt;usize&gt;() {
                    Ok(a) =&gt; Ok(Person { name: p[0].to_string(), age: a }),
                    Err(a) =&gt; Err(ParseInt(a)),
                }
            }
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-errempty---err-is-a-variant-not-a-module" class="admonition failure">
<summary class="admonition-title">
<p>solution2: Err::Empty -&gt; <em>Err</em> is a variant, not a module</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution2-errempty---err-is-a-variant-not-a-module"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
        if s.is_empty() {
            Err::Empty // i.e., Err(ParsePersonError::Empty)
        } else {
            let p: Vec&lt;&amp;str&gt; = s.split(',').collect();
            if p.len() != 2 {
                Err::BadLen
            } else if p[0].len() == 0 {
                Err::NoName
            } else { 
                match p[1].parse::&lt;usize&gt;() {
                    Ok(a) =&gt; Ok(Person { name: p[0].to_string(), age: a }),
                    Err(a) =&gt; Err::ParseInt(a),
                }
            }
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution3-errempty" class="admonition failure">
<summary class="admonition-title">
<p>solution3: Err.Empty()</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution3-errempty"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
        if s.is_empty() {
            Err.Empty // i.e., Err(ParsePersonError::Empty)
        } else {
            let p: Vec&lt;&amp;str&gt; = s.split(',').collect();
            if p.len() != 2 {
                Err.BadLen
            } else if p[0].len() == 0 {
                Err.NoName
            } else { 
                match p[1].parse::&lt;usize&gt;() {
                    Ok(a) =&gt; Ok(Person { name: p[0].to_string(), age: a }),
                    Err(a) =&gt; Err.ParseInt(a),
                }
            }
        }
    }
}

</code></pre></pre>
</div>
</details>
<details id="admonition-solution4-parsepersonerrorerrortype" class="admonition success">
<summary class="admonition-title">
<p>solution4: ParsePersonError::{ErrorType}</p>
<p><a class="admonition-anchor-link" href="conversions/conversions.html#admonition-solution4-parsepersonerrorerrortype"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// Using ParsePersonError::{Empty, BadLen, NoName, ParseInt} above
impl FromStr for Person {
    type Err = ParsePersonError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {
        if s.is_empty() { // 1. If the length of the provided string is 0, an error should be returned
            Err(ParsePersonError::Empty) // i.e., Err(ParsePersonError::Empty)
        } else {
            let p: Vec&lt;&amp;str&gt; = s.split(',').collect(); // 2. Split the given string on the commas present in it
            if p.len() != 2 { // 3. Only 2 elements should be returned from the split, otherwise return an error
                Err(ParsePersonError::BadLen)
            } else if p[0].len() == 0 { // 4. Extract the first element from the split operation and use it as the name
                Err(ParsePersonError::NoName)
            } else { 
                match p[1].parse::&lt;usize&gt;() { //  5. Extract the other element from the split operation and parse it into a `usize` as the age with something like `&quot;4&quot;.parse::&lt;usize&gt;()`
                    Ok(a) =&gt; Ok(Person { name: p[0].to_string(), age: a }), // 7. If everything goes well, then return a Result of a Person object
                    Err(a) =&gt; Err(ParsePersonError::ParseInt(a)), // 6. If while extracting the name and the age something goes wrong, an error should be returned
                }
            }
        }
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<!--ts-->
<ul>
<li><a href="error_handling/error_handling.html#error-handling">Error handling</a>
<ul>
<li><a href="error_handling/error_handling.html#is-option-part-of-error-handling">Is Option part of error handling</a></li>
<li><a href="error_handling/error_handling.html#further-information">Further information</a></li>
<li><a href="error_handling/error_handling.html#rustlings">Rustlings</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Thu Mar 16 14:35:08 UTC 2023 -->
<!--te-->
<ol>
<li>Most errors aren’t serious enough to require the program to stop entirely.</li>
<li>Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to.</li>
</ol>
<blockquote>
<p>For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.</p>
</blockquote>
<h2 id="is-option-part-of-error-handling"><a class="header" href="#is-option-part-of-error-handling">Is Option<T> part of error handling</a></h2>
<blockquote>
<p>In Rust, an “option” is not technically part of error handling, but it is often used in combination with error handling to represent the possibility of a value being absent or “None.”</p>
</blockquote>
<ol>
<li>An “option” is a type that represents either Some value or None.</li>
</ol>
<ul>
<li>When a function may not return a value, it can return an Option<T> where T is the type of the value that might be returned.</li>
<li>If the function succeeds and returns a value, it returns Some(value); otherwise, it returns None.</li>
</ul>
<blockquote>
<p>Error handling in Rust typically uses the Result&lt;T, E&gt; type</p>
</blockquote>
<ul>
<li>where T is the type of the value that is returned if the operation succeeds</li>
<li>and E is the type of the error that may occur.</li>
<li>When an error occurs, a value of type E is returned, and when the operation succeeds, a value of type T is returned.</li>
</ul>
<blockquote>
<p>So while Option and Result are different types in Rust, they are often used in combination to handle situations where a value may or may not be present or when an operation may or may not succeed.</p>
</blockquote>
<h2 id="further-information-10"><a class="header" href="#further-information-10">Further information</a></h2>
<ul>
<li><a href="https://www.zhihu.com/question/36444352">Rust 使用 Result 的错误处理方式与 Golang 使用 error 的方式有什么本质区别？ - 知乎</a>: <a href="x-devonthink-item://21BCF1DC-17A0-428C-BA20-A1F1A515B207">dt link</a></li>
<li><a href="https://kuanhsiaokuo.github.io/geektime-tyr-rust/3_3_1_error_content.html">错误处理内容和主流方法 - Anatomy In First Rust Programming Class 🦀</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch09-02-recoverable-errors-with-result.html">⭐️Recoverable Errors with Result - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-01-syntax.html">✨Generic Data Types - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error.html">⭐️Error handling: Panic、Option and Result - The Rust Programming Language</a>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/result.html">Result &amp; OK or ?: A Richer Version Of Option - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/option_unwrap/question_mark.html">Unpacking options with ? to return the Some or terminate - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/multiple_error_types/boxing_errors.html">Boxing errors - The Rust Programming Language</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/error_handling">rustlings-solutions-5/error_handling at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<h2 id="rustlings-9"><a class="header" href="#rustlings-9">Rustlings</a></h2>
<details id="admonition-errors1-change-option-to-result" class="admonition note">
<summary class="admonition-title">
<p>errors1: change Option<T> to Result&lt;T, E&gt;</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors1-change-option-to-result"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors1.rs
// This function refuses to generate text to be printed on a nametag if
// you pass it an empty string. It'd be nicer if it explained what the problem
// was, instead of just sometimes returning `None`. Thankfully, Rust has a similar
// construct to `Option` that can be used to express error conditions. Let's use it!
// Execute `rustlings hint errors1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn generate_nametag_text(name: String) -&gt; Option&lt;String&gt; {
    if name.is_empty() {
        // Empty names aren't allowed.
        None
    } else {
        Some(format!(&quot;Hi! My name is {}&quot;, name))
    }
}

// convert unit tests to main
fn main() {
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text(&quot;Beyoncé&quot;.into()),
            Ok(&quot;Hi! My name is Beyoncé&quot;.into())
        );
    }

    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&quot;&quot;.into()),
            // Don't change this line
            Err(&quot;`name` was empty; it must be nonempty.&quot;.into())
        );
    }
    generates_nametag_text_for_a_nonempty_name();
    explains_why_generating_nametag_text_fails();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_nametag_text_for_a_nonempty_name() {
        assert_eq!(
            generate_nametag_text(&quot;Beyoncé&quot;.into()),
            Ok(&quot;Hi! My name is Beyoncé&quot;.into())
        );
    }

    #[test]
    fn explains_why_generating_nametag_text_fails() {
        assert_eq!(
            generate_nametag_text(&quot;&quot;.into()),
            // Don't change this line
            Err(&quot;`name` was empty; it must be nonempty.&quot;.into())
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint"></a></p>
</summary>
<div>
<p><code>Ok</code> and <code>Err</code> are one of the variants of <code>Result</code>, so what the tests are saying
is that <code>generate_nametag_text</code> should return a <code>Result</code> instead of an
<code>Option</code>.</p>
<p>To make this change, you’ll need to:</p>
<ul>
<li>update the return type in the function signature to be a Result&lt;String, String&gt; that
could be the variants <code>Ok(String)</code> and <code>Err(String)</code></li>
<li>change the body of the function to return <code>Ok(stuff)</code> where it currently
returns <code>Some(stuff)</code></li>
<li>change the body of the function to return <code>Err(error message)</code> where it
currently returns <code>None</code></li>
</ul>
</div>
</details>
<details id="admonition-solution-result" class="admonition success">
<summary class="admonition-title">
<p>solution: Result&lt;String, String&gt;</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution-result"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">pub fn generate_nametag_text(name: String) -&gt; Result&lt;String, String&gt; {
    if name.is_empty() {
        // Empty names aren't allowed.
        Err(format!(&quot;`name` was empty; it must be nonempty.&quot;))
    } else {
        Ok(format!(&quot;Hi! My name is {}&quot;, name))
    }
}
</code></pre></pre>
<ol>
<li>这里其实单元测试代码已经指出要报错的内容</li>
<li>Result&lt;T, E&gt;中，E其实就是各种Err</li>
</ol>
</div>
</details>
<hr />
<ul>
<li>Say we’re writing a game where you can buy items with tokens. All items cost
5 tokens, and whenever you purchase items there is a processing fee of 1
token.</li>
<li>A player of the game will type in how many items they want to buy,
and the <code>total_cost</code> function will calculate the total number of tokens.</li>
<li>Since the player typed in the quantity, though, we get it as a string– and
they might have typed anything, not just numbers!</li>
</ul>
<blockquote>
<p>Right now, this function isn’t handling the error case at all (and isn’t
handling the success case properly either). What we want to do is:</p>
</blockquote>
<ul>
<li>if we call the <code>parse</code> function on a string that is not a number, that
function will return a <code>ParseIntError</code>,</li>
<li>and in that case, we want to
immediately return that error from our function and not try to multiply
and add.</li>
</ul>
<blockquote>
<p>There are at least two ways to implement this that are both correct– but
one is a lot shorter!</p>
</blockquote>
<details id="admonition-errors2-unwrap_err" class="admonition note">
<summary class="admonition-title">
<p>⭐️errors2: unwrap_err()</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors2-unwrap_err"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors2.rs
// Say we're writing a game where you can buy items with tokens. All items cost
// 5 tokens, and whenever you purchase items there is a processing fee of 1
// token. A player of the game will type in how many items they want to buy,
// and the `total_cost` function will calculate the total number of tokens.
// Since the player typed in the quantity, though, we get it as a string-- and
// they might have typed anything, not just numbers!

// Right now, this function isn't handling the error case at all (and isn't
// handling the success case properly either). What we want to do is:
// if we call the `parse` function on a string that is not a number, that
// function will return a `ParseIntError`, and in that case, we want to
// immediately return that error from our function and not try to multiply
// and add.

// There are at least two ways to implement this that are both correct-- but
// one is a lot shorter!
// Execute `rustlings hint errors2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&lt;i32&gt;();

    Ok(qty * cost_per_item + processing_fee)
}

// convert unit tests to main
fn main() {
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost(&quot;34&quot;), Ok(171));
    }

    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost(&quot;beep boop&quot;).unwrap_err().to_string(),
            &quot;invalid digit found in string&quot;
        );
    }
    item_quantity_is_a_valid_number();
    item_quantity_is_an_invalid_number()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn item_quantity_is_a_valid_number() {
        assert_eq!(total_cost(&quot;34&quot;), Ok(171));
    }

    #[test]
    fn item_quantity_is_an_invalid_number() {
        assert_eq!(
            total_cost(&quot;beep boop&quot;).unwrap_err().to_string(),
            &quot;invalid digit found in string&quot;
        );
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint-1"></a></p>
</summary>
<div>
<ol>
<li>One way to handle this is using a <code>match</code> statement on
<code>item_quantity.parse::&lt;i32&gt;()</code> where the cases are <code>Ok(something)</code> and
<code>Err(something)</code>. This pattern is very common in Rust, though, so there’s
a <code>?</code> operator that does pretty much what you would make that match statement
do for you!</li>
<li>Take a look at this section of the <code>match expression</code> part in Error Handling chapter:</li>
</ol>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch09-02-recoverable-errors-with-result.html#match-expression-how-to-hanle-the-information">⭐️Recoverable Errors with Result - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/result/early_returns.html">Early returns: Catch Exception and Return - The Rust Programming Language</a>
and give it a try!</li>
</ul>
</div>
</details>
<details id="admonition-solution1-match-err-to-panic-return" class="admonition success">
<summary class="admonition-title">
<p>solution1: match err to panic! return</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution1-match-err-to-panic-return"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = match item_quantity.parse::&lt;i32&gt;(){
        Ok(iqty) =&gt; iqty,
        Err(error) =&gt; panic!(&quot;Problem parsing the item_quantity: {:?}&quot;, error),
    };

    Ok(qty * cost_per_item + processing_fee)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-match-err-to-early-return" class="admonition success">
<summary class="admonition-title">
<p>solution2: match err to early return</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution2-match-err-to-early-return"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = match item_quantity.parse::&lt;i32&gt;(){
        Ok(iqty) =&gt; iqty,
        Err(e) =&gt; return Err(e),
    };

    Ok(qty * cost_per_item + processing_fee)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution3-return-custom-error-message" class="admonition danger">
<summary class="admonition-title">
<p>⌛️solution3: return custom error message</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution3-return-custom-error-message"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">todo()
// return Err(String::from(&quot;invalid digit found in string&quot;)),
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-errors3----return-result-or-option-to-accept-" class="admonition note">
<summary class="admonition-title">
<p>errors3: ? -&gt; return <em>Result</em> or <em>Option</em> to accept <em>?</em></p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors3----return-result-or-option-to-accept-"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors3.rs
// This is a program that is trying to use a completed version of the
// `total_cost` function from the previous exercise. It's not working though!
// Why not? What should we do to fix it?
// Execute `rustlings hint errors3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

fn main() {
    let mut tokens = 100;
    let pretend_user_input = &quot;8&quot;;

    let cost = total_cost(pretend_user_input)?;

    if cost &gt; tokens {
        println!(&quot;You can't afford that many!&quot;);
    } else {
        tokens -= cost;
        println!(&quot;You now have {} tokens.&quot;, tokens);
    }
}

pub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::&lt;i32&gt;()?;

    Ok(qty * cost_per_item + processing_fee)
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint-2"></a></p>
</summary>
<div>
<blockquote>
<p>If other functions can return a <code>Result</code>, why shouldn’t <code>main</code>? </p>
</blockquote>
<p>It’s a fairly common
convention to return something like Result&lt;(), ErrorType&gt; from your main function.
The unit (<code>()</code>) type is there because nothing is really needed in terms of positive
results.</p>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/option_unwrap/question_mark.html">Unpacking options with ? to return the Some or terminate - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/multiple_error_types/reenter_question_mark.html">Other uses of ? - The Rust Programming Language</a></li>
</ul>
</div>
</details>
<details id="admonition-solution-just-like-async-fn-to-accept-await---return-result-to-chain-" class="admonition danger">
<summary class="admonition-title">
<p>⚡️️solution: just like async fn to accept await -&gt; return Result&lt;T, E&gt; to chain ?</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution-just-like-async-fn-to-accept-await---return-result-to-chain-"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn main() -&gt; Result&lt;(), ParseIntError&gt;{ // main function also could return Result&lt;T, E&gt;
    let mut tokens = 100;
    let pretend_user_input = &quot;8&quot;;

    let cost = total_cost(pretend_user_input)?; // should return Result to accept ?, if got error, here will return ParseIntError

    if cost &gt; tokens {
        println!(&quot;You can't afford that many!&quot;);
    } else {
        tokens -= cost;
        println!(&quot;You now have {} tokens.&quot;, tokens);
    }
    Ok(()) // if successed, here return the OK result ()
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-errors4" class="admonition note">
<summary class="admonition-title">
<p>errors4</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors4.rs
// Execute `rustlings hint errors4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        // Hmm...? Why is this only returning an Ok value?
        Ok(PositiveNonzeroInteger(value as u64))
    }
}

// convert unit tests to main
fn main() {
    fn test_creation() {
        assert!(PositiveNonzeroInteger::new(10).is_ok());
        assert_eq!(
            Err(CreationError::Negative),
            PositiveNonzeroInteger::new(-10)
        );
        assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
    }
    test_creation();
}

#[test]
fn test_creation() {
    assert!(PositiveNonzeroInteger::new(10).is_ok());
    assert_eq!(
        Err(CreationError::Negative),
        PositiveNonzeroInteger::new(-10)
    );
    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint-3"></a></p>
</summary>
<div>
<blockquote>
<p><code>PositiveNonzeroInteger::new</code> is always creating a new instance and returning an <code>Ok</code> result.</p>
</blockquote>
<p>It should be doing some checking, returning an <code>Err</code> result if those checks fail, and only
returning an <code>Ok</code> result if those checks determine that everything is… okay :)</p>
</div>
</details>
<details id="admonition-solution1-use-if-to-catch-err" class="admonition success">
<summary class="admonition-title">
<p>solution1: use if to catch err</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution1-use-if-to-catch-err"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        // Hmm...? Why is this only returning an Ok value?
        if value &lt; 0 {
            Err(CreationError::Negative)
        } else if value == 0 {
            Err(CreationError::Zero)
        } else {
            Ok(PositiveNonzeroInteger(value as u64))
        }      
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-use-match-to-catch-err" class="admonition success">
<summary class="admonition-title">
<p>solution2: use match to catch err</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution2-use-match-to-catch-err"></a></p>
</summary>
<div>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/match/guard.html">Guards: to filter the arm - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/match/binding.html">@ Binding - The Rust Programming Language</a></li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        // Hmm...? Why is this only returning an Ok value?
        match value {
            v if v &lt; 0 =&gt; return Err(CreationError::Negative),
            v if v == 0 =&gt; return Err(CreationError::Zero),
            _ =&gt; return Ok(PositiveNonzeroInteger(value as u64))
        }
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<ul>
<li>This exercise uses some concepts that we won’t get to until later in the course, like <code>Box</code> and the
<code>From</code> trait.</li>
<li>It’s not important to understand them in detail right now, but you can read ahead if you like.</li>
</ul>
<blockquote>
<p>For now, think of the <code>Box&lt;dyn ...&gt;</code> type as an “I want anything that does ???” type, which, given
Rust’s usual standards for runtime safety, should strike you as somewhat lenient!</p>
</blockquote>
<ul>
<li>In short, this particular use case for boxes is for when you want to own a value and you care only that it is a type which implements a particular trait.</li>
<li>To do so, The Box is declared as of type <code>Box&lt;dyn Trait&gt;</code> where Trait is the trait the compiler looks for on any value used in that context.</li>
<li>For this exercise, that context is the potential errors which can be returned in a Result.</li>
</ul>
<blockquote>
<p>What can we use to describe both errors? In other words, is there a trait which both errors implement?</p>
</blockquote>
<details id="admonition-errors5" class="admonition note">
<summary class="admonition-title">
<p>errors5</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors5.rs

// This program uses an altered version of the code from errors4.

// This exercise uses some concepts that we won't get to until later in the course, like `Box` and the
// `From` trait. It's not important to understand them in detail right now, but you can read ahead if you like.
// For now, think of the `Box&lt;dyn ...&gt;` type as an &quot;I want anything that does ???&quot; type, which, given
// Rust's usual standards for runtime safety, should strike you as somewhat lenient!

// In short, this particular use case for boxes is for when you want to own a value and you care only that it is a
// type which implements a particular trait. To do so, The Box is declared as of type Box&lt;dyn Trait&gt; where Trait is the trait
// the compiler looks for on any value used in that context. For this exercise, that context is the potential errors
// which can be returned in a Result.

// What can we use to describe both errors? In other words, is there a trait which both errors implement?

// Execute `rustlings hint errors5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::error;
use std::fmt;
use std::num::ParseIntError;

// TODO: update the return type of `main()` to make this compile.
fn main() -&gt; Result&lt;(), Box&lt;dyn ???&gt;&gt; {
    let pretend_user_input = &quot;42&quot;;
    let x: i64 = pretend_user_input.parse()?;
    println!(&quot;output={:?}&quot;, PositiveNonzeroInteger::new(x)?);
    Ok(())
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

// This is required so that `CreationError` can implement `error::Error`.
impl fmt::Display for CreationError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let description = match *self {
            CreationError::Negative =&gt; &quot;number is negative&quot;,
            CreationError::Zero =&gt; &quot;number is zero&quot;,
        };
        f.write_str(description)
    }
}

impl error::Error for CreationError {}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-4" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint-4"></a></p>
</summary>
<div>
<p>There are two different possible <code>Result</code> types produced within <code>main()</code>, which are
propagated using <code>?</code> operators. </p>
<blockquote>
<p>How do we declare a return type from <code>main()</code> that allows both?</p>
</blockquote>
<ul>
<li>Under the hood, the <code>?</code> operator calls <code>From::from</code> on the error value to convert it to a boxed trait object, a <code>Box&lt;dyn error::Error&gt;</code>. </li>
<li>This boxed trait object is <code>polymorphic</code>, and since all errors implement the <code>error::Error</code> trait, we can capture lots of different errors in one “Box” object.</li>
</ul>
<p>Check out this section of the book:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the–operator</p>
<p>Read more about boxing errors: <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch09-02-recoverable-errors-with-result.html#the--operator-a-shortcut-for-propagating-errors">⭐️Recoverable Errors with Result - The Rust Programming Language</a></p>
<p>Read more about using the <code>?</code> operator with boxed errors: <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/error/multiple_error_types/reenter_question_mark.html">Other uses of ? - The Rust Programming Language</a></p>
</div>
</details>
<details id="admonition-solution-errorerror-trait" class="admonition success">
<summary class="admonition-title">
<p>solution: error::Error trait</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution-errorerror-trait"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">Box&lt;dyn error::Error&gt;
</code></pre></pre>
</div>
</details>
<hr />
<p>Using catch-all error types like <code>Box&lt;dyn error::Error&gt;</code> isn’t recommended
for library code:</p>
<blockquote>
<p>where callers might want to make decisions based on the
error content, instead of printing it out or propagating it further.</p>
</blockquote>
<p>Here, we define a custom error type to make it possible for callers to decide
what to do next when our function returns an error.</p>
<details id="admonition-errors6" class="admonition note">
<summary class="admonition-title">
<p>errors6</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-errors6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// errors6.rs

// Using catch-all error types like `Box&lt;dyn error::Error&gt;` isn't recommended
// for library code, where callers might want to make decisions based on the
// error content, instead of printing it out or propagating it further. Here,
// we define a custom error type to make it possible for callers to decide
// what to do next when our function returns an error.

// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::num::ParseIntError;

// This is a custom error type that we will be using in `parse_pos_nonzero()`.
#[derive(PartialEq, Debug)]
enum ParsePosNonzeroError {
    Creation(CreationError),
    ParseInt(ParseIntError),
}

impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    // TODO: add another error conversion function here.
    // fn from_parseint...
}

fn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    let x: i64 = s.parse().unwrap();
    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)
}

// Don't change anything below this line.

#[derive(PartialEq, Debug)]
struct PositiveNonzeroInteger(u64);

#[derive(PartialEq, Debug)]
enum CreationError {
    Negative,
    Zero,
}

impl PositiveNonzeroInteger {
    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {
        match value {
            x if x &lt; 0 =&gt; Err(CreationError::Negative),
            x if x == 0 =&gt; Err(CreationError::Zero),
            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),
        }
    }
}

// convert unit tests to main
fn main() {
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero(&quot;not a number&quot;),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero(&quot;-555&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero(&quot;0&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero(&quot;42&quot;), Ok(x.unwrap()));
    }
    test_parse_error();
    test_negative();
    test_zero();
    test_positive();
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_error() {
        // We can't construct a ParseIntError, so we have to pattern match.
        assert!(matches!(
            parse_pos_nonzero(&quot;not a number&quot;),
            Err(ParsePosNonzeroError::ParseInt(_))
        ));
    }

    #[test]
    fn test_negative() {
        assert_eq!(
            parse_pos_nonzero(&quot;-555&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Negative))
        );
    }

    #[test]
    fn test_zero() {
        assert_eq!(
            parse_pos_nonzero(&quot;0&quot;),
            Err(ParsePosNonzeroError::Creation(CreationError::Zero))
        );
    }

    #[test]
    fn test_positive() {
        let x = PositiveNonzeroInteger::new(42);
        assert!(x.is_ok());
        assert_eq!(parse_pos_nonzero(&quot;42&quot;), Ok(x.unwrap()));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-5" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-hint-5"></a></p>
</summary>
<div>
<blockquote>
<p>This exercise uses a completed version of <code>PositiveNonzeroInteger</code> from
errors4.</p>
</blockquote>
<ul>
<li>Below the line that TODO asks you to change, there is an example of using the <code>map_err()</code> method on a <code>Result</code> to transform one type of error into another.</li>
<li>Try using something similar on the <code>Result</code> from <code>parse()</code>.</li>
<li>You might use the <code>?</code> operator to return early from the function</li>
<li>or you might use a <code>match</code> expression, or maybe there’s another way!</li>
</ul>
<blockquote>
<p>You can create another function inside <code>impl ParsePosNonzeroError</code> to use
with <code>map_err()</code>.</p>
</blockquote>
<p>Read more about <code>map_err()</code> in the <code>std::result</code> documentation:
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err">Result in std::result - Rust</a></p>
</div>
</details>
<details id="admonition-solution-define-a-custom-error-type" class="admonition success">
<summary class="admonition-title">
<p>solution: define a custom error type</p>
<p><a class="admonition-anchor-link" href="error_handling/error_handling.html#admonition-solution-define-a-custom-error-type"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">impl ParsePosNonzeroError {
    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::Creation(err)
    }
    // TODO: add another error conversion function here.
    // fn from_parseint...
    fn from_parseint(err: ParseIntError) -&gt; ParsePosNonzeroError {
        ParsePosNonzeroError::ParseInt(err)
    }
}

fn parse_pos_nonzero(s: &amp;str)
    -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt;
{
    // TODO: change this to return an appropriate error instead of panicking
    // when `parse()` returns an error.
    // let x: i64 = s.parse().unwrap();
    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;

    PositiveNonzeroInteger::new(x)
        .map_err(ParsePosNonzeroError::from_creation)
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>Type <code>Option</code> represents an optional value: every Option is either Some and contains a value, or None, and does not.</p>
<blockquote>
<p>Option types are very common in Rust code, as they have a number of uses:</p>
</blockquote>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where None is returned on error</li>
<li>Optional struct fields</li>
<li>Struct fields that can be loaned or “taken”</li>
<li>Optional function arguments</li>
<li>Nullable pointers</li>
<li>Swapping things out of difficult situations</li>
</ul>
<h2 id="further-information-11"><a class="header" href="#further-information-11">Further Information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-01-syntax.html#in-enum-definitions">✨Generic Data Types-&gt;Option Enum Format - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/std/option/">Option Module Documentation</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option Enum Documentation</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/if_let.html">if let - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/while_let.html">while let - The Rust Programming Language</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/options">rustlings-solutions-5/options at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<h2 id="rustlings-10"><a class="header" href="#rustlings-10">Rustlings</a></h2>
<details id="admonition-options1" class="admonition failure">
<summary class="admonition-title">
<p>options1</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options1.rs
// Execute `rustlings hint options1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// This function returns how much icecream there is left in the fridge.
// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them
// all, so there'll be no more left :(
fn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; {
    // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0
    // The Option output should gracefully handle cases where time_of_day &gt; 23.
    // TODO: Complete the function body - remember to return an Option!
    ? ? ?
}

// convert unit tests to main
fn main() {
    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
    }

    fn raw_value() {
        // TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, 5);
    }
    check_icecream();
    raw_value();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_icecream() {
        assert_eq!(maybe_icecream(9), Some(5));
        assert_eq!(maybe_icecream(10), Some(5));
        assert_eq!(maybe_icecream(23), Some(0));
        assert_eq!(maybe_icecream(22), Some(0));
        assert_eq!(maybe_icecream(25), None);
    }

    #[test]
    fn raw_value() {
        // TODO: Fix this test. How do you get at the value contained in the Option?
        let icecreams = maybe_icecream(12);
        assert_eq!(icecreams, 5);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-hint"></a></p>
</summary>
<div>
<p>Options can have a Some value, with an inner value, or a None value, without an inner value.</p>
<p>There’s multiple ways to get at the inner value, you can use <code>unwrap</code>, or <code>pattern match</code>. </p>
<blockquote>
<p>Unwrapping is the easiest, but how do you do it safely so that it doesn’t panic in your face later?</p>
</blockquote>
</div>
</details>
<details id="admonition-solution1-pattern-match" class="admonition success">
<summary class="admonition-title">
<p>solution1: pattern match </p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-solution1-pattern-match"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; {
    // We use the 24-hour system here, so 10PM is a value of 22
    // The Option output should gracefully handle cases where time_of_day &gt; 24.
    match time_of_day {
        0..=21 =&gt; Some(5),
        22..=24 =&gt; Some(0),
        _ =&gt; None,
    }
    // Exclusive range (e.g., 0..22) pattern use here is experimental
    // on rustc 1.62.1
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">assert_eq!(icecreams.unwrap_or(0), 5); // Use unwrapped Some or 0 
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-options2" class="admonition failure">
<summary class="admonition-title">
<p>options2</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options2.rs
// Execute `rustlings hint options2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE
// convert unit tests to main
fn main() {
    fn simple_option() {
        let target = &quot;rustlings&quot;;
        let optional_target = Some(target);

        // TODO: Make this an if let statement whose value is &quot;Some&quot; type
        word = optional_target {
            assert_eq!(word, target);
        }
    }

    fn layered_option() {
        let mut range = 10;
        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();
        for i in 0..(range + 1) {
            optional_integers.push(Some(i));
        }

        // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;
        // You can stack `Option&lt;T&gt;`'s into while let and if let
        integer = optional_integers.pop()
        {
            assert_eq!(integer, range);
            range -= 1;
        }
    }
    simple_option();
    layered_option();
}

#[cfg(test)]
mod tests {
    #[test]
    fn simple_option() {
        let target = &quot;rustlings&quot;;
        let optional_target = Some(target);

        // TODO: Make this an if let statement whose value is &quot;Some&quot; type
        word = optional_target {
            assert_eq!(word, target);
        }
    }

    #[test]
    fn layered_option() {
        let mut range = 10;
        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = Vec::new();
        for i in 0..(range + 1) {
            optional_integers.push(Some(i));
        }

        // TODO: make this a while let statement - remember that vector.pop also adds another layer of Option&lt;T&gt;
        // You can stack `Option&lt;T&gt;`'s into while let and if let
        integer = optional_integers.pop()
        {
            assert_eq!(integer, range);
            range -= 1;
        }
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>check out:</p>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/if_let.html">if let - The Rust Programming Language</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/flow_control/while_let.html">while let - The Rust Programming Language</a></li>
</ul>
<p>Remember that Options can be stacked in if let and while let.
For example: Some(Some(variable)) = variable2
Also see Option::flatten</p>
</div>
</details>
<details id="admonition-solution-if-let--while-let" class="admonition success">
<summary class="admonition-title">
<p>solution: if let &amp; while let</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-solution-if-let--while-let"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">        if let Some(word) = optional_target {
            assert_eq!(word, target);
        }
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable">        while let Some(integer) = optional_integers.pop().flatten() {
            assert_eq!(integer, range);
            range -= 1;
        }
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-options3-ref---value-partially-moved-here" class="admonition failure">
<summary class="admonition-title">
<p>options3: ref -&gt; value partially moved here</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-options3-ref---value-partially-moved-here"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// options3.rs
// Execute `rustlings hint options3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let y: Option&lt;Point&gt; = Some(Point { x: 100, y: 200 });

    match y {
        Some(p) =&gt; println!(&quot;Co-ordinates are {},{} &quot;, p.x, p.y),
        _ =&gt; println!(&quot;no match&quot;),
    }
    y; // Fix without deleting this line.
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>The compiler says a <code>partial move</code> happened in the <code>match</code>
statement.</p>
<p>How can this be avoided? The compiler shows the correction needed.
After making the correction as suggested by the compiler, do
read: <a href="https://doc.rust-lang.org/std/keyword.ref.html">ref - Rust</a></p>
</div>
</details>
<details id="admonition-solution-ref" class="admonition success">
<summary class="admonition-title">
<p>solution: ref </p>
<p><a class="admonition-anchor-link" href="options/options.html#admonition-solution-ref"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">Some(ref p)
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics is the topic of generalizing types and functionalities to broader cases.
This is extremely useful for reducing code duplication in many ways, but can call for rather involving syntax.
Namely, being generic requires taking great care to specify over which types a generic type is actually considered valid.
The simplest and most common use of generics is for type parameters.</p>
<h2 id="further-information-12"><a class="header" href="#further-information-12">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html">Generic Data Types</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">Bounds</a></li>
</ul>
<h2 id="rustlings-11"><a class="header" href="#rustlings-11">Rustlings</a></h2>
<details id="admonition-generics1" class="admonition failure">
<summary class="admonition-title">
<p>generics1</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-generics1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut shopping_list: Vec&lt;?&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;);
}
</code></pre></pre>
</div>
</details>
<blockquote>
<p><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/generics">rustlings-solutions-5/generics at main · gaveen/rustlings-solutions-5</a></p>
</blockquote>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-hint"></a></p>
</summary>
<div>
<p>Vectors in Rust make use of generics to create dynamically sized arrays of any type.
You need to tell the compiler what type we are pushing onto this vector.</p>
</div>
</details>
<details id="admonition-solution1-str" class="admonition success">
<summary class="admonition-title">
<p>solution1: &amp;str</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-solution1-str"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut shopping_list: Vec&lt;&amp;str&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-solution2-string" class="admonition bug">
<summary class="admonition-title">
<p>solution2: String</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-solution2-string"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This shopping list program isn't compiling!
// Use your knowledge of generics to fix it.

// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a hint.

fn main() {
    let mut shopping_list: Vec&lt;String&gt; = Vec::new();
    shopping_list.push(&quot;milk&quot;); // fix here
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-generics2" class="admonition failure">
<summary class="admonition-title">
<p>generics2</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-generics2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Wrapper {
    value: u32,
}

impl Wrapper {
    pub fn new(value: u32) -&gt; Self {
        Wrapper { value }
    }
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn store_u32_in_wrapper() {
//         assert_eq!(Wrapper::new(42).value, 42);
//     }
//
//     #[test]
//     fn store_str_in_wrapper() {
//         assert_eq!(Wrapper::new(&quot;Foo&quot;).value, &quot;Foo&quot;);
//     }
// }

// change to run in playground
fn main() {
    assert_eq!(Wrapper::new(42).value, 42);
    assert_eq!(Wrapper::new(&quot;Foo&quot;).value, &quot;Foo&quot;);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Currently we are wrapping only values of type ‘u32’.
Maybe we could update the explicit references to this data type somehow?</p>
<p>If you are still stuck, please read:</p>
<blockquote>
<p><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-01-syntax.html#in-method-definitions">✨Generic Data Types - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<details id="admonition-solution1-convert-to-use-generics" class="admonition bug">
<summary class="admonition-title">
<p>solution1: convert to use generics</p>
<p><a class="admonition-anchor-link" href="generics/generics.html#admonition-solution1-convert-to-use-generics"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// This powerful wrapper provides the ability to store a positive integer value.
// Rewrite it using generics so that it supports wrapping ANY type.

struct Wrapper { // fix here
    value: T,
}

impl&lt;T&gt; Wrapper&lt;T&gt; {
    pub fn new(value: T) -&gt; Self {
        Wrapper { value }
    }
}

fn main() {
    assert_eq!(Wrapper::new(42).value, 42);
    assert_eq!(Wrapper::new(&quot;Foo&quot;).value, &quot;Foo&quot;);
}
</code></pre></pre>
</div>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait is a collection of methods.</p>
<p>Data types can implement traits. To do so, the methods making up the trait are defined for the data type. For example, the <code>String</code> data type implements the <code>From&lt;&amp;str&gt;</code> trait. This allows a user to write <code>String::from(&quot;hello&quot;)</code>.</p>
<p>In this way, traits are somewhat similar to Java interfaces and C++ abstract classes.</p>
<p>Some additional common Rust traits include:</p>
<ul>
<li><code>Clone</code> (the <code>clone</code> method)</li>
<li><code>Display</code> (which allows formatted display via <code>{}</code>)</li>
<li><code>Debug</code> (which allows formatted display via <code>{:?}</code>)</li>
</ul>
<p>Because traits indicate shared behavior between data types, they are useful when writing generics.</p>
<h2 id="further-information-13"><a class="header" href="#further-information-13">Further information</a></h2>
<ul>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax">Traits</a></li>
<li><a href="https://github.com/gaveen/rustlings-solutions-5/tree/main/traits">rustlings-solutions-5/traits at main · gaveen/rustlings-solutions-5</a></li>
</ul>
<h2 id="rustlings-12"><a class="header" href="#rustlings-12">Rustlings</a></h2>
<details id="admonition-traits1-time-to-implement-some-traits" class="admonition note">
<summary class="admonition-title">
<p>traits1: Time to implement some traits!</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits1-time-to-implement-some-traits"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits1.rs
// Time to implement some traits!
//
// Your task is to implement the trait
// `AppendBar` for the type `String`.
//
// The trait AppendBar has only one function,
// which appends &quot;Bar&quot; to any object
// implementing this trait.
// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

impl AppendBar for String {
    // TODO: Implement `AppendBar` for type `String`.
}

fn main() {
    let s = String::from(&quot;Foo&quot;);
    let s = s.append_bar();
    println!(&quot;s: {}&quot;, s);
    // convert unit test to play in playground
    assert_eq!(
        String::from(&quot;Foo&quot;).append_bar(),
        String::from(&quot;FooBar&quot;)
    );

    assert_eq!(
        String::from(&quot;&quot;).append_bar().append_bar(),
        String::from(&quot;BarBar&quot;)
    );
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn is_foo_bar() {
//         assert_eq!(String::from(&quot;Foo&quot;).append_bar(), String::from(&quot;FooBar&quot;));
//     }
//
//     #[test]
//     fn is_bar_bar() {
//         assert_eq!(
//             String::from(&quot;&quot;).append_bar().append_bar(),
//             String::from(&quot;BarBar&quot;)
//         );
//     }
// }

</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-hint"></a></p>
</summary>
<div>
<p>A discussion about Traits in Rust can be found at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-02-traits.html">🪐Traits: Defining Shared Behavior - The Rust Programming Language</a></p>
</div>
</details>
<details id="admonition-solution-string" class="admonition bug">
<summary class="admonition-title">
<p>solution: String</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-solution-string"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">impl AppendBar for String {
    //Add your code here
    fn append_bar(self) -&gt; Self {
        format!(&quot;{}Bar&quot;, self)
        // or
        // format!(&quot;{self}Bar&quot;)
        // or
        // self + &quot;Bar&quot;
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-traits2-implement-the-trait-for-a-vector-of-strings" class="admonition note">
<summary class="admonition-title">
<p>traits2: implement the trait for a vector of strings.</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits2-implement-the-trait-for-a-vector-of-strings"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits2.rs
//
// Your task is to implement the trait
// `AppendBar` for a vector of strings.
//
// To implement this trait, consider for
// a moment what it means to 'append &quot;Bar&quot;'
// to a vector of strings.
//
// No boiler plate code this time,
// you can do this!
// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

trait AppendBar {
    fn append_bar(self) -&gt; Self;
}

// TODO: Implement trait `AppendBar` for a vector of strings.

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn is_vec_pop_eq_bar() {
//         let mut foo = vec![String::from(&quot;Foo&quot;)].append_bar();
//         assert_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));
//         assert_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));
//     }
// }

fn main() {
    // convert unit test to main to play in playground
    let mut foo = vec![String::from(&quot;Foo&quot;)].append_bar();
    assert_eq!(foo.pop().unwrap(), String::from(&quot;Bar&quot;));
    assert_eq!(foo.pop().unwrap(), String::from(&quot;Foo&quot;));
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>Notice how the trait takes ownership of ‘self’,and returns <code>Self</code>.
Try mutating the incoming string vector. Have a look at the tests to see
what the result should look like!</p>
<p>Vectors provide suitable methods for adding an element at the end. See
the documentation at: 
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec in std::vec - Rust</a></p>
</div>
</details>
<details id="admonition-solution-vec" class="admonition bug">
<summary class="admonition-title">
<p>solution: Vec<String> </p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-solution-vec"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">// Add your code here
impl AppendBar for Vec&lt;String&gt; {
    fn append_bar(mut self) -&gt; Self { // Borrow self as `mut`
        self.push(&quot;Bar&quot;.to_string());
        self
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-traits3-implement-the-licensed-trait-for-both-structures-and-have-them-return-the-same-information-without-writing-the-same-function-twice" class="admonition note">
<summary class="admonition-title">
<p>traits3: implement the Licensed trait for both structures and have them return the same information without writing the same function twice.</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits3-implement-the-licensed-trait-for-both-structures-and-have-them-return-the-same-information-without-writing-the-same-function-twice"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits3.rs
//
// Your task is to implement the Licensed trait for
// both structures and have them return the same
// information without writing the same function twice.
//
// Consider what you can add to the Licensed trait.
// Execute `rustlings hint traits3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;self) -&gt; String;
}

struct SomeSoftware {
    version_number: i32,
}

struct OtherSoftware {
    version_number: String,
}

impl Licensed for SomeSoftware {} // Don't edit this line
impl Licensed for OtherSoftware {} // Don't edit this line

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn is_licensing_info_the_same() {
//         let licensing_info = String::from(&quot;Some information&quot;);
//         let some_software = SomeSoftware { version_number: 1 };
//         let other_software = OtherSoftware {
//             version_number: &quot;v2.0.0&quot;.to_string(),
//         };
//         assert_eq!(some_software.licensing_info(), licensing_info);
//         assert_eq!(other_software.licensing_info(), licensing_info);
//     }
// }

fn main() {
    // convert unit test to main to play in playground
    let licensing_info = String::from(&quot;Some information&quot;);
    let some_software = SomeSoftware { version_number: 1 };
    let other_software = OtherSoftware {
        version_number: &quot;v2.0.0&quot;.to_string(),
    };
    assert_eq!(some_software.licensing_info(), licensing_info);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>Traits can have a default implementation for functions. Structs that implement
the trait can then use the default version of these functions if they choose not
implement the function themselves.</p>
<p>See the documentation at: 
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-02-traits.html#default-implementations">🪐Traits: Defining Shared Behavior &gt;&gt; Default Implementations - The Rust Programming Language</a></p>
</div>
</details>
<details id="admonition-solution-default-trait-method" class="admonition bug">
<summary class="admonition-title">
<p>solution: Default Trait Method</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-solution-default-trait-method"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">pub trait Licensed {
    fn licensing_info(&amp;self) -&gt; String {
        String::from(&quot;Some information&quot;)
    }
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-traits4-trait-bounds" class="admonition note">
<summary class="admonition-title">
<p>traits4: trait bounds</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits4-trait-bounds"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits4.rs
//
// Your task is to replace the '??' sections so the code compiles.
// Don't change any line other than the marked one.
// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait Licensed {
    fn licensing_info(&amp;self) -&gt; String {
        &quot;some information&quot;.to_string()
    }
}

struct SomeSoftware {}

struct OtherSoftware {}

impl Licensed for SomeSoftware {}

impl Licensed for OtherSoftware {}

// YOU MAY ONLY CHANGE THE NEXT LINE
fn compare_license_types(software: ? ?, software_two: ? ?) -&gt; bool {
    software.licensing_info() == software_two.licensing_info()
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn compare_license_information() {
//         let some_software = SomeSoftware {};
//         let other_software = OtherSoftware {};
//
//         assert!(compare_license_types(some_software, other_software));
//     }
//
//     #[test]
//     fn compare_license_information_backwards() {
//         let some_software = SomeSoftware {};
//         let other_software = OtherSoftware {};
//
//         assert!(compare_license_types(other_software, some_software));
//     }
// }

fn main() {
    // convert unit test to main to play in playground
    // compare_license_information
    let some_software = SomeSoftware {};
    let other_software = OtherSoftware {};

    assert!(compare_license_types(some_software, other_software));

    // compare_license_information_backwards
    let some_software = SomeSoftware {};
    let other_software = OtherSoftware {};

    assert!(compare_license_types(other_software, some_software));
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-hint-3"></a></p>
</summary>
<div>
<p>Instead of using concrete types as parameters you can use traits. Try replacing the
‘??’ with ‘impl &lt;what goes here?&gt;’</p>
<p>See the documentation at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-02-traits.html#traits-as-parameters">🪐Traits: Defining Shared Behavior &gt;&gt; Traits as Parameters - The Rust Programming Language</a></p>
</div>
</details>
<details id="admonition-solution-impl" class="admonition bug">
<summary class="admonition-title">
<p>solution: impl</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-solution-impl"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">fn compare_license_types(software: impl Licensed, software_two: impl Licensed) -&gt; bool {
    software.licensing_info() == software_two.licensing_info()
}
</code></pre></pre>
</div>
</details>
<hr />
<details id="admonition-traits5-impl-multiple-traits" class="admonition note">
<summary class="admonition-title">
<p>traits5: impl multiple traits</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-traits5-impl-multiple-traits"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// traits5.rs
//
// Your task is to replace the '??' sections so the code compiles.
// Don't change any line other than the marked one.
// Execute `rustlings hint traits5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub trait SomeTrait {
    fn some_function(&amp;self) -&gt; bool {
        true
    }
}

pub trait OtherTrait {
    fn other_function(&amp;self) -&gt; bool {
        true
    }
}

struct SomeStruct {}
struct OtherStruct {}

impl SomeTrait for SomeStruct {}
impl OtherTrait for SomeStruct {}
impl SomeTrait for OtherStruct {}
impl OtherTrait for OtherStruct {}

// YOU MAY ONLY CHANGE THE NEXT LINE
fn some_func(item: ??) -&gt; bool {
    item.some_function() &amp;&amp; item.other_function()
}

fn main() {
    some_func(SomeStruct {});
    some_func(OtherStruct {});
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-4" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-hint-4"></a></p>
</summary>
<div>
<p>To ensure a parameter implements multiple traits use the ‘+ syntax’. Try replacing the
‘??’ with ‘impl &lt;&gt; + &lt;&gt;’.</p>
<p>See the documentation at:
<a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</a></p>
</div>
</details>
<details id="admonition-solution-impl-or-where" class="admonition bug">
<summary class="admonition-title">
<p>solution: impl or where</p>
<p><a class="admonition-anchor-link" href="traits/traits.html#admonition-solution-impl-or-where"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">fn some_func&lt;T&gt;(item: T) -&gt; bool
    where T: SomeTrait + OtherTrait
{
    item.some_function() &amp;&amp; item.other_function()
}

fn some_func(item: impl SomeTrait + OtherTrait) -&gt; bool {
    item.some_function() &amp;&amp; item.other_function()
}

</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rust’s macro system is very powerful, but also kind of difficult to wrap your
head around. We’re not going to teach you how to write your own fully-featured
macros. Instead, we’ll show you how to use and create them.</p>
<p>If you’d like to learn more about writing your own macros, the
<a href="https://github.com/tfpk/macrokata">macrokata</a> project has a similar style
of exercises to Rustlings, but is all about learning to write Macros.</p>
<h2 id="further-information-14"><a class="header" href="#further-information-14">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Macros</a></li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></li>
</ul>
<h2 id="rustlings-13"><a class="header" href="#rustlings-13">Rustlings</a></h2>
<details id="admonition-macros1" class="admonition note">
<summary class="admonition-title">
<p>macros1</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros1.rs
// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}

fn main() {
    my_macro();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros2" class="admonition note">
<summary class="admonition-title">
<p>macros2</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros2.rs
// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    };
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros3" class="admonition note">
<summary class="admonition-title">
<p>macros3</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros3.rs
// Make me compile, without taking the macro out of the module!
// Execute `rustlings hint macros3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod macros {
    macro_rules! my_macro {
        () =&gt; {
            println!(&quot;Check out my macro!&quot;);
        };
    }
}

fn main() {
    my_macro!();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-macros4" class="admonition note">
<summary class="admonition-title">
<p>macros4</p>
<p><a class="admonition-anchor-link" href="macros/macros.html#admonition-macros4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// macros4.rs
// Execute `rustlings hint macros4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Check out my macro!&quot;);
    }
    ($val:expr) =&gt; {
        println!(&quot;Look at this other macro: {}&quot;, $val);
    }
}

fn main() {
    my_macro!();
    my_macro!(7777);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</p>
<p>If you used the installation script for Rustlings, Clippy should be already installed.
If not you can install it manually via <code>rustup component add clippy</code>.</p>
<h2 id="further-information-15"><a class="header" href="#further-information-15">Further information</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy">GitHub Repository</a>.</li>
</ul>
<h2 id="rustlings-14"><a class="header" href="#rustlings-14">Rustlings</a></h2>
<details id="admonition-clippy1" class="admonition note">
<summary class="admonition-title">
<p>clippy1</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy1.rs
// The Clippy tool is a collection of lints to analyze your code
// so you can catch common mistakes and improve your Rust code.
//
// For these exercises the code will fail to compile when there are clippy warnings
// check clippy's suggestions from the output to solve the exercise.
// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::f32;

fn main() {
    let pi = 3.14f32;
    let radius = 5.00f32;

    let area = pi * f32::powi(radius, 2);

    println!(
        &quot;The area of a circle with radius {:.2} is {:.5}!&quot;,
        radius, area
    )
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clippy2" class="admonition note">
<summary class="admonition-title">
<p>clippy2</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy2.rs
// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut res = 42;
    let option = Some(12);
    for x in option {
        res += x;
    }
    println!(&quot;{}&quot;, res);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-clippy3" class="admonition note">
<summary class="admonition-title">
<p>clippy3</p>
<p><a class="admonition-anchor-link" href="clippy/clippy.html#admonition-clippy3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// clippy3.rs
// Here's a couple more easy Clippy fixes, so you can see its utility.

// I AM NOT DONE

#[allow(unused_variables, unused_assignments)]
fn main() {
    let my_option: Option&lt;()&gt; = None;
    if my_option.is_none() {
        my_option.unwrap();
    }

    let my_arr = &amp;[
        -1, -2, -3
        -4, -5, -6
    ];
    println!(&quot;My array! Here it is: {:?}&quot;, my_arr);

    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);
    println!(&quot;This Vec is empty, see? {:?}&quot;, my_empty_vec);

    let mut value_a = 45;
    let mut value_b = 66;
    // Let's swap these two!
    value_a = value_b;
    value_b = value_a;
    println!(&quot;value a: {}; value b: {}&quot;, value_a, value_b);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Here, you’ll learn how to write functions and how the Rust compiler can help you debug errors even
in more complex code.</p>
<h2 id="further-information-16"><a class="header" href="#further-information-16">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">How Functions Work</a></li>
</ul>
<h2 id="rustlings-15"><a class="header" href="#rustlings-15">Rustlings</a></h2>
<details id="admonition-functions1" class="admonition note">
<summary class="admonition-title">
<p>functions1</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions1.rs
// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions2" class="admonition note">
<summary class="admonition-title">
<p>functions2</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions2.rs
// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me(3);
}

fn call_me(num:) {
    for i in 0..num {
        println!(&quot;Ring! Call number {}&quot;, i + 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions3" class="admonition note">
<summary class="admonition-title">
<p>functions3</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions3.rs
// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    call_me();
}

fn call_me(num: u32) {
    for i in 0..num {
        println!(&quot;Ring! Call number {}&quot;, i + 1);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions4" class="admonition note">
<summary class="admonition-title">
<p>functions4</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions4.rs
// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a hint.

// This store is having a sale where if the price is an even number, you get
// 10 Rustbucks off, but if it's an odd number, it's 3 Rustbucks off.
// (Don't worry about the function bodies themselves, we're only interested
// in the signatures for now. If anything, this is a good way to peek ahead
// to future exercises!)

// I AM NOT DONE

fn main() {
    let original_price = 51;
    println!(&quot;Your sale price is {}&quot;, sale_price(original_price));
}

fn sale_price(price: i32) -&gt; {
    if is_even(price) {
        price - 10
    } else {
        price - 3
    }
}

fn is_even(num: i32) -&gt; bool {
    num % 2 == 0
}
</code></pre></pre>
</div>
</details>
<details id="admonition-functions5" class="admonition note">
<summary class="admonition-title">
<p>functions5</p>
<p><a class="admonition-anchor-link" href="functions/functions.html#admonition-functions5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// functions5.rs
// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let answer = square(3);
    println!(&quot;The square of 3 is {}&quot;, answer);
}

fn square(num: i32) -&gt; i32 {
    num * num;
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">If</a></h1>
<p><code>if</code>, the most basic (but still surprisingly versatile!) type of control flow, is what you’ll learn here.</p>
<h2 id="further-information-17"><a class="header" href="#further-information-17">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#if-expressions">Control Flow - if expressions</a></li>
</ul>
<h2 id="rustlings-16"><a class="header" href="#rustlings-16">Rustlings</a></h2>
<details id="admonition-if1" class="admonition note">
<summary class="admonition-title">
<p>if1</p>
<p><a class="admonition-anchor-link" href="if/if.html#admonition-if1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// if1.rs
// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn bigger(a: i32, b: i32) -&gt; i32 {
    // Complete this function to return the bigger number!
    // Do not use:
    // - another function call
    // - additional variables
}

// Don't mind this for now :)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ten_is_bigger_than_eight() {
        assert_eq!(10, bigger(10, 8));
    }

    #[test]
    fn fortytwo_is_bigger_than_thirtytwo() {
        assert_eq!(42, bigger(32, 42));
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-if2" class="admonition note">
<summary class="admonition-title">
<p>if2</p>
<p><a class="admonition-anchor-link" href="if/if.html#admonition-if2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// if2.rs

// Step 1: Make me compile!
// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!
// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {
    if fizzish == &quot;fizz&quot; {
        &quot;foo&quot;
    } else {
        1
    }
}

// No test changes needed!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_for_fizz() {
        assert_eq!(foo_if_fizz(&quot;fizz&quot;), &quot;foo&quot;)
    }

    #[test]
    fn bar_for_fuzz() {
        assert_eq!(foo_if_fizz(&quot;fuzz&quot;), &quot;bar&quot;)
    }

    #[test]
    fn default_to_baz() {
        assert_eq!(foo_if_fizz(&quot;literally anything&quot;), &quot;baz&quot;)
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<!--ts-->
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#lifetimes">Lifetimes</a>
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#further-information">Further information</a></li>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#rustlings">Rustlings</a>
<ul>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#returns-a-value-referencing-data-owned-by-the-current-function">returns a value referencing data owned by the current function</a></li>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#expected-named-lifetime-parameter">expected named lifetime parameter</a></li>
<li><a href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#borrowed-value-does-not-live-long-enough">borrowed value does not live long enough</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Thu Mar 16 14:35:11 UTC 2023 -->
<!--te-->
<p>Lifetimes tell the compiler how to check:</p>
<blockquote>
<p>whether <code>references</code> live long enough to be valid in any given situation.</p>
</blockquote>
<p>For example lifetimes say “make sure parameter ‘a’ lives as long as parameter ‘b’ so that the return value is valid”.</p>
<blockquote>
<p>They are only necessary on borrows, i.e. references</p>
</blockquote>
<ul>
<li>Since copied parameters or moves are owned in their scope and cannot
be referenced outside.</li>
<li>Lifetimes mean that calling code of e.g. functions
can be checked to make sure their arguments are valid.</li>
<li>Lifetimes are restrictive of their callers.</li>
</ul>
<h2 id="further-information-18"><a class="header" href="#further-information-18">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Validating References with Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/scope/lifetime.html">Lifetimes (in Rust By Example)</a></li>
<li><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/rust_by_example_src/scope/lifetime.html">Lifetimes - The Rust Programming Language</a></li>
</ul>
<h2 id="rustlings-17"><a class="header" href="#rustlings-17">Rustlings</a></h2>
<h3 id="returns-a-value-referencing-data-owned-by-the-current-function"><a class="header" href="#returns-a-value-referencing-data-owned-by-the-current-function">returns a value referencing data owned by the current function</a></h3>
<h3 id="expected-named-lifetime-parameter"><a class="header" href="#expected-named-lifetime-parameter">expected named lifetime parameter</a></h3>
<details id="admonition-function" class="admonition bug">
<summary class="admonition-title">
<p>function</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-function"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes1.rs
//
// The Rust compiler needs to know how to check whether supplied references are
// valid, so that it can let the programmer know if a reference is at risk
// of going out of scope before it is used. Remember, references are borrows
// and do not own their own data. What if their owner goes out of scope?
//
// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is '{}'&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint"></a></p>
</summary>
<div>
<p>Let the compiler guide you. Also take a look at <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch10-03-lifetime-syntax.html">the book</a> if you need help:</p>
</div>
</details>
<details id="admonition-struct" class="admonition bug">
<summary class="admonition-title">
<p>struct</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-struct"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes3.rs
//
// Lifetimes are also needed when structs hold references.
//
// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

struct Book {
    author: &amp;str,
    title: &amp;str,
}

fn main() {
    let name = String::from(&quot;Jill Smith&quot;);
    let title = String::from(&quot;Fish Flying&quot;);
    let book = Book { author: &amp;name, title: &amp;title };

    println!(&quot;{} by {}&quot;, book.title, book.author);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>If you use a lifetime annotation in a struct’s fields, where else does it need to be added?</p>
</div>
</details>
<h3 id="borrowed-value-does-not-live-long-enough"><a class="header" href="#borrowed-value-does-not-live-long-enough">borrowed value does not live long enough</a></h3>
<details id="admonition-lifetimes2" class="admonition bug">
<summary class="admonition-title">
<p>lifetimes2</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-lifetimes2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// lifetimes2.rs
//
// So if the compiler is just validating the references passed
// to the annotated parameters and the return type, what do
// we need to change?
//
// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is '{}'&quot;, result);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-将块看作生命周期隐式声明" class="admonition tip">
<summary class="admonition-title">
<p>Hint: 将块看作生命周期隐式声明</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-将块看作生命周期隐式声明"></a></p>
</summary>
<div>
<p>Remember that the generic lifetime ’a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.
You can take at least two paths to achieve the desired result while keeping the inner block:</p>
<ol>
<li>Move the string2 declaration to make it live as long as string1 (how is result declared?)</li>
<li>Move println! into the inner block</li>
</ol>
</div>
</details>
<details id="admonition-qa" class="admonition info">
<summary class="admonition-title">
<p>Q&amp;A</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-qa"></a></p>
</summary>
<div>
<h2 id="q-为什么不能改成"><a class="header" href="#q-为什么不能改成">Q: 为什么不能改成</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a:'b, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'b str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A: 因为可能返回’a x, 也可能返回’b y. 这里主要问题在于返回的引用有两种生命周期。</p>
</blockquote>
</div>
</details>
<details id="admonition-lifetimes4" class="admonition bug">
<summary class="admonition-title">
<p>lifetimes4</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-lifetimes4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">extern crate regex; // just for running in rust playground
use regex::Regex;

fn get_publish_date(title: String) -&gt; String{
    let date_re = Regex::new(r&quot;(\d{4}-\d{2}-\d{2})&quot;).unwrap();
    // let publish_date = date_re.captures(title.as_str()).unwrap().get(1).unwrap().as_str();
    // ----------------------------------------------------^^^^^^ here to match.
    let publish_date = match date_re.captures(title.as_str()) {
        Some(captured) =&gt; captured.get(1).unwrap().as_str(), // 这里unwrap()之后只有as_str()方法, 没有to_string()
        // None =&gt; format!(&quot;Unable to extract date from {}&quot;, title).as_str() // temporary value is freed at the end of this statement
        // None =&gt; &quot;Unable to extract date from {title}&quot; // str is equal to &amp;'static str ?
        None =&gt; {
            let temp = format!(&quot;Unable to extract date from {}&quot;, title);
            temp.as_str()
        }
    };
    publish_date.to_string()
}

fn main() {
    let title = &quot;【Rust Daily】2023-01-21&quot;; // &amp;str
    let publish_date = get_publish_date(title);
    println!(&quot;Title: {}\nPublish_data: {}\n&quot;, title, publish_date);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-函数返回引用才会考虑live-long-enough" class="admonition tip">
<summary class="admonition-title">
<p>Hint: 函数返回引用才会考虑live long enough</p>
<p><a class="admonition-anchor-link" href="ref_borrow_lifetimes/ref_borrow_lifetimes.html#admonition-hint-函数返回引用才会考虑live-long-enough"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust  editable">extern crate regex; // just for running in rust playground
use regex::Regex;

fn get_publish_date(title: &amp;str) -&gt; String{
    let date_re = Regex::new(r&quot;(\d{4}-\d{2}-\d{2})&quot;).unwrap();
    // let publish_date = date_re.captures(title.as_str()).unwrap().get(1).unwrap().as_str();
    // ----------------------------------------------------^^^^^^ here to match.
    let publish_date = match date_re.captures(title) {
        Some(captured) =&gt; captured.get(1).unwrap().as_str().to_string(), // 这里unwrap()之后只有as_str()方法, 没有to_string()
        // None =&gt; format!(&quot;Unable to extract date from {}&quot;, title).as_str() // temporary value is freed at the end of this statement
        // None =&gt; &quot;Unable to extract date from {title}&quot; // str is equal to &amp;'static str ?
        None =&gt; format!(&quot;Unable to extract date from {}&quot;, title)
    };
    publish_date
}

fn main() {
    let title = &quot;【Rust Daily】2023-01-21&quot;;
    let publish_date = get_publish_date(title);
    println!(&quot;Title: {}\nPublish_data: {}\n&quot;, title, publish_date);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>In this section we’ll give you an introduction to Rust’s module system.</p>
<h2 id="further-information-19"><a class="header" href="#further-information-19">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">The Module System</a></li>
</ul>
<h2 id="rustlings-18"><a class="header" href="#rustlings-18">Rustlings</a></h2>
<details id="admonition-modules1-pub" class="admonition note">
<summary class="admonition-title">
<p>modules1: pub</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules1-pub"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules1.rs
// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod sausage_factory {
    // Don't let anybody outside of this module see this!
    fn get_secret_recipe() -&gt; String {
        String::from(&quot;Ginger&quot;)
    }

    fn make_sausage() {
        get_secret_recipe();
        println!(&quot;sausage!&quot;);
    }
}

fn main() {
    sausage_factory::make_sausage();
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint"></a></p>
</summary>
<div>
<blockquote>
<p>add <code>pub</code>
Everything is private in Rust by default– but there’s a keyword we can use
to make something public! The compiler error should point to the thing that
needs to be public.</p>
</blockquote>
</div>
</details>
<details id="admonition-modules2-use-selfxxx-as-bbb" class="admonition note">
<summary class="admonition-title">
<p>modules2: use self::xxx as bbb</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules2-use-selfxxx-as-bbb"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules2.rs
// You can bring module paths into scopes and provide new names for them with the
// 'use' and 'as' keywords. Fix these 'use' statements to make the code compile.
// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

mod delicious_snacks {
    // TODO: Fix these use statements
    use self::fruits::PEAR as ???
    use self::veggies::CUCUMBER as ???

    mod fruits {
        pub const PEAR: &amp;'static str = &quot;Pear&quot;;
        pub const APPLE: &amp;'static str = &quot;Apple&quot;;
    }

    mod veggies {
        pub const CUCUMBER: &amp;'static str = &quot;Cucumber&quot;;
        pub const CARROT: &amp;'static str = &quot;Carrot&quot;;
    }
}

fn main() {
    println!(
        &quot;favorite snacks: {} and {}&quot;,
        delicious_snacks::fruit,
        delicious_snacks::veggie
    );
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>The delicious_snacks module is trying to present an external interface that is
different than its internal structure (the <code>fruits</code> and <code>veggies</code> modules and
associated constants). Complete the <code>use</code> statements to fit the uses in main and
find the one keyword missing for both constants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub use self::fruits::PEAR as fruit;
    pub use self::veggies::CUCUMBER as veggie;
<span class="boring">}
</span></code></pre></pre>
</div>
</details>
<details id="admonition-modules3" class="admonition note">
<summary class="admonition-title">
<p>modules3</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-modules3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// modules3.rs
// You can use the 'use' keyword to bring module paths from modules from anywhere
// and especially from the Rust standard library into your scope.
// Bring SystemTime and UNIX_EPOCH
// from the std::time module. Bonus style points if you can do it with one line!
// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

// TODO: Complete this use statement
use ???

fn main() {
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&gt; println!(&quot;1970-01-01 00:00:00 UTC was {} seconds ago!&quot;, n.as_secs()),
        Err(_) =&gt; panic!(&quot;SystemTime before UNIX EPOCH!&quot;),
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="modules/modules.html#admonition-hint-2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{SystemTime, UNIX_EPOCH};
<span class="boring">}
</span></code></pre></pre>
<p>UNIX_EPOCH and SystemTime are declared in the std::time module. Add a use statement
for these two to bring them into scope. You can use nested paths or the glob
operator to bring these two in using only one line.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<!--ts-->
<ul>
<li><a href="move_semantics/move_semantics.html#move-semantics">Move Semantics</a>
<ul>
<li><a href="move_semantics/move_semantics.html#further-information">Further information</a></li>
<li><a href="move_semantics/move_semantics.html#rustlings">Rustlings</a>
<ul>
<li><a href="move_semantics/move_semantics.html#%E5%80%9F%E7%94%A8">借用</a></li>
<li><a href="move_semantics/move_semantics.html#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">可变借用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Thu Mar 16 14:35:10 UTC 2023 -->
<!--te-->
<p>These exercises are adapted from <a href="https://github.com/pnkfelix">pnkfelix</a>’s <a href="https://pnkfelix.github.io/rust-examples-icfp2014/">Rust Tutorial</a> – Thank you Felix!!!</p>
<h2 id="further-information-20"><a class="header" href="#further-information-20">Further information</a></h2>
<p>For this section, the book links are especially important.</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">Reference and borrowing</a></li>
</ul>
<h2 id="rustlings-19"><a class="header" href="#rustlings-19">Rustlings</a></h2>
<h3 id="借用"><a class="header" href="#借用">借用</a></h3>
<details id="admonition-move_semantics1" class="admonition note">
<summary class="admonition-title">
<p>move_semantics1</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics1.rs
// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let vec1 = fill_vec(vec0);

    // let vec1 = fill_vec(&amp;vec0);
    // vec0.push(24); // Try accessing `vec0` after having called `fill_vec()`. See what happens!

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint"></a></p>
</summary>
<div>
<p>So you’ve got the “cannot borrow immutable local variable <code>vec1</code> as mutable” error on line 13,
right? The fix for this is going to be adding one keyword, and the addition is NOT on line 13
where the error is.</p>
<p>Also: Try accessing <code>vec0</code> after having called <code>fill_vec()</code>. See what happens!</p>
</div>
</details>
<h3 id="可变借用"><a class="header" href="#可变借用">可变借用</a></h3>
<details id="admonition-move_semantics2" class="admonition note">
<summary class="admonition-title">
<p>move_semantics2</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics2.rs
// Make me compile without changing line 13 or moving line 10!
// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    // Do not change the following line!
    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec0&quot;, vec0.len(), vec0);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-1" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-1"></a></p>
</summary>
<div>
<p>So, <code>vec0</code> is passed into the <code>fill_vec</code> function as an argument. In Rust,
when an argument is passed to a function and it’s not explicitly returned,
you can’t use the original variable anymore. We call this “moving” a variable.
Variables that are moved into a function (or block scope) and aren’t explicitly
returned get “dropped” at the end of that function. This is also what happens here.
There’s a few ways to fix this, try them all if you want:</p>
<ol>
<li>Make another, separate version of the data that’s in <code>vec0</code> and pass that
to <code>fill_vec</code> instead.</li>
<li>Make <code>fill_vec</code> borrow its argument instead of taking ownership of it,
and then copy the data within the function in order to return an owned
<code>Vec&lt;i32&gt;</code></li>
<li>Make <code>fill_vec</code> <em>mutably</em> borrow a reference to its argument (which will need to be
mutable), modify it directly, then not return anything. Then you can get rid
of <code>vec1</code> entirely – note that this will change what gets printed by the
first <code>println!</code></li>
</ol>
</div>
</details>
<details id="admonition-move_semantics3" class="admonition note">
<summary class="admonition-title">
<p>move_semantics3</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics3.rs
// Make me compile without adding new lines-- just changing existing lines!
// (no lines with multiple semicolons necessary!)
// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

fn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-2" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-2"></a></p>
</summary>
<div>
<p>The difference between this one and the previous ones is that the first line
of <code>fn fill_vec</code> that had <code>let mut vec = vec;</code> is no longer there. You can,
instead of adding that line back, add <code>mut</code> in one place that will change
an existing binding to be a mutable binding instead of an immutable one :)</p>
</div>
</details>
<details id="admonition-move_semantics4" class="admonition note">
<summary class="admonition-title">
<p>move_semantics4</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics4.rs
// Refactor this code so that instead of passing `vec0` into the `fill_vec` function,
// the Vector gets created in the function itself and passed back to the main
// function.
// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let vec0 = Vec::new();

    let mut vec1 = fill_vec(vec0);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);

    vec1.push(88);

    println!(&quot;{} has length {} content `{:?}`&quot;, &quot;vec1&quot;, vec1.len(), vec1);
}

// `fill_vec()` no longer takes `vec: Vec&lt;i32&gt;` as argument
fn fill_vec() -&gt; Vec&lt;i32&gt; {
    let mut vec = vec;

    vec.push(22);
    vec.push(44);
    vec.push(66);

    vec
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-3" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-3"></a></p>
</summary>
<div>
<p>Stop reading whenever you feel like you have enough direction :) Or try
doing one step and then fixing the compiler errors that result!
So the end goal is to:</p>
<ul>
<li>get rid of the first line in main that creates the new vector</li>
<li>so then <code>vec0</code> doesn’t exist, so we can’t pass it to <code>fill_vec</code></li>
<li>we don’t want to pass anything to <code>fill_vec</code>, so its signature should
reflect that it does not take any arguments</li>
<li>since we’re not creating a new vec in <code>main</code> anymore, we need to create
a new vec in <code>fill_vec</code>, similarly to the way we did in <code>main</code></li>
</ul>
</div>
</details>
<details id="admonition-move_semantics5" class="admonition note">
<summary class="admonition-title">
<p>move_semantics5</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics5.rs
// Make me compile only by reordering the lines in `main()`, but without
// adding, changing or removing any of them.
// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let mut x = 100;
    let y = &amp;mut x;
    let z = &amp;mut x;
    *y += 100;
    *z += 1000;
    assert_eq!(x, 1200);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-4" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-4"></a></p>
</summary>
<div>
<p>Carefully reason about the range in which each mutable reference is in
scope. Does it help to update the value of referent (x) immediately after
the mutable reference is taken? Read more about ‘Mutable References’:</p>
<blockquote>
<p><a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch04-02-references-and-borrowing.html#mutable-references">References and Borrowing &gt; Mutable References - The Rust Programming Language</a></p>
</blockquote>
</div>
</details>
<details id="admonition-move_semantics6" class="admonition note">
<summary class="admonition-title">
<p>move_semantics6</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-move_semantics6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// move_semantics6.rs
// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand for a hint.
// You can't change anything except adding or removing references.

// I AM NOT DONE

fn main() {
    let data = &quot;Rust is great!&quot;.to_string();

    get_char(data);

    string_uppercase(&amp;data);
}

// Should not take ownership
fn get_char(data: String) -&gt; char {
    data.chars().last().unwrap()
}

// Should take ownership
fn string_uppercase(mut data: &amp;String) {
    data = &amp;data.to_uppercase();

    println!(&quot;{}&quot;, data);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-hint-5" class="admonition tip">
<summary class="admonition-title">
<p>Hint</p>
<p><a class="admonition-anchor-link" href="move_semantics/move_semantics.html#admonition-hint-5"></a></p>
</summary>
<div>
<p>To find the answer, you can consult the book section <a href="https://kuanhsiaokuo.github.io/the-rust-programming-book-khk/ch04-02-references-and-borrowing.html#references-and-borrowing">“References and Borrowing”</a></p>
<ol>
<li>
<p>The first problem is that <code>get_char</code> is taking ownership of the string.
So <code>data</code> is moved and can’t be used for <code>string_uppercase</code>
<code>data</code> is moved to <code>get_char</code> first, meaning that <code>string_uppercase</code> cannot manipulate the data.
Once you’ve fixed that, <code>string_uppercase</code>’s function signature will also need to be adjusted.
Can you figure out how?</p>
</li>
<li>
<p>Another hint: it has to do with the <code>&amp;</code> character.</p>
</li>
</ol>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Going out of order from the book to cover tests – many of the following exercises will ask you to make tests pass!</p>
<h2 id="further-information-21"><a class="header" href="#further-information-21">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">Writing Tests</a></li>
</ul>
<h2 id="rustlings-20"><a class="header" href="#rustlings-20">Rustlings</a></h2>
<details id="admonition-tests1" class="admonition note">
<summary class="admonition-title">
<p>tests1</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests1.rs
// Tests are important to ensure that your code does what you think it should do.
// Tests can be run on this file with the following command:
// rustlings run tests1

// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert() {
        assert!();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-tests2" class="admonition note">
<summary class="admonition-title">
<p>tests2</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests2.rs
// This test has a problem with it -- make the test compile! Make the test
// pass! Make the test fail!
// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

#[cfg(test)]
mod tests {
    #[test]
    fn you_can_assert_eq() {
        assert_eq!();
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-tests3" class="admonition note">
<summary class="admonition-title">
<p>tests3</p>
<p><a class="admonition-anchor-link" href="tests/tests.html#admonition-tests3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// tests3.rs
// This test isn't testing our function -- make it do that in such a way that
// the test passes. Then write a second test that tests whether we get the result
// we expect to get when we call `is_even(5)`.
// Execute `rustlings hint tests3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

pub fn is_even(num: i32) -&gt; bool {
    num % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_true_when_even() {
        assert!();
    }

    #[test]
    fn is_false_when_odd() {
        assert!();
    }
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>In most current operating systems, an executed program’s code is run in a process, and the operating system manages multiple processes at once.
Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads.</p>
<h2 id="further-information-22"><a class="header" href="#further-information-22">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/1.4.0/book/dining-philosophers.html">Dining Philosophers example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch16-01-threads.html">Using Threads to Run Code Simultaneously</a></li>
</ul>
<h2 id="rustlings-21"><a class="header" href="#rustlings-21">Rustlings</a></h2>
<details id="admonition-threads1" class="admonition note">
<summary class="admonition-title">
<p>threads1</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads1.rs
// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a hint.

// This program spawns multiple threads that each run for at least 250ms,
// and each thread returns how much time they took to complete.
// The program should wait until all the spawned threads have finished and
// should collect their return values into a vector.

// I AM NOT DONE

use std::thread;
use std::time::{Duration, Instant};

fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        handles.push(thread::spawn(move || {
            let start = Instant::now();
            thread::sleep(Duration::from_millis(250));
            println!(&quot;thread {} is complete&quot;, i);
            start.elapsed().as_millis()
        }));
    }

    let mut results: Vec&lt;u128&gt; = vec![];
    for handle in handles {
        // TODO: a struct is returned from thread::spawn, can you use it?
    }

    if results.len() != 10 {
        panic!(&quot;Oh no! All the spawned threads did not finish!&quot;);
    }
    
    println!();
    for (i, result) in results.into_iter().enumerate() {
        println!(&quot;thread {} took {}ms&quot;, i, result);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-threads2" class="admonition note">
<summary class="admonition-title">
<p>threads2</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads2.rs
// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a hint.
// Building on the last exercise, we want all of the threads to complete their work but this time
// the spawned threads need to be in charge of updating a shared value: JobStatus.jobs_completed

// I AM NOT DONE

use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct JobStatus {
    jobs_completed: u32,
}

fn main() {
    let status = Arc::new(JobStatus { jobs_completed: 0 });
    let mut handles = vec![];
    for _ in 0..10 {
        let status_shared = Arc::clone(&amp;status);
        let handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(250));
            // TODO: You must take an action before you update a shared value
            status_shared.jobs_completed += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice anything
        // interesting in the output? Do you have to 'join' on all the handles?
        println!(&quot;jobs completed {}&quot;, ???);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-threads3" class="admonition note">
<summary class="admonition-title">
<p>threads3</p>
<p><a class="admonition-anchor-link" href="threads/threads.html#admonition-threads3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// threads3.rs
// Execute `rustlings hint threads3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

use std::sync::mpsc;
use std::sync::Arc;
use std::thread;
use std::time::Duration;

struct Queue {
    length: u32,
    first_half: Vec&lt;u32&gt;,
    second_half: Vec&lt;u32&gt;,
}

impl Queue {
    fn new() -&gt; Self {
        Queue {
            length: 10,
            first_half: vec![1, 2, 3, 4, 5],
            second_half: vec![6, 7, 8, 9, 10],
        }
    }
}

fn send_tx(q: Queue, tx: mpsc::Sender&lt;u32&gt;) -&gt; () {
    let qc = Arc::new(q);
    let qc1 = Arc::clone(&amp;qc);
    let qc2 = Arc::clone(&amp;qc);

    thread::spawn(move || {
        for val in &amp;qc1.first_half {
            println!(&quot;sending {:?}&quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        for val in &amp;qc2.second_half {
            println!(&quot;sending {:?}&quot;, val);
            tx.send(*val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
}

fn main() {
    let (tx, rx) = mpsc::channel();
    let queue = Queue::new();
    let queue_length = queue.length;

    send_tx(queue, tx);

    let mut total_received: u32 = 0;
    for received in rx {
        println!(&quot;Got: {}&quot;, received);
        total_received += 1;
    }

    println!(&quot;total numbers received: {}&quot;, total_received);
    assert_eq!(total_received, queue_length)
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>In Rust, variables are immutable by default.
When a variable is immutable, once a value is bound to a name, you can’t change that value.
You can make them mutable by adding mut in front of the variable name.</p>
<h2 id="further-information-23"><a class="header" href="#further-information-23">Further information</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">Variables and Mutability</a></li>
</ul>
<h2 id="rustlings-22"><a class="header" href="#rustlings-22">Rustlings</a></h2>
<details id="admonition-variables1" class="admonition note">
<summary class="admonition-title">
<p>variables1</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables1"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables1.rs
// Make me compile!
// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    x = 5;
    println!(&quot;x has the value {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables2" class="admonition note">
<summary class="admonition-title">
<p>variables2</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables2"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables2.rs
// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x;
    if x == 10 {
        println!(&quot;x is ten!&quot;);
    } else {
        println!(&quot;x is not ten!&quot;);
    }
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables3" class="admonition note">
<summary class="admonition-title">
<p>variables3</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables3"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables3.rs
// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x: i32;
    println!(&quot;Number {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables4" class="admonition note">
<summary class="admonition-title">
<p>variables4</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables4"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables4.rs
// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let x = 3;
    println!(&quot;Number {}&quot;, x);
    x = 5; // don't change this line
    println!(&quot;Number {}&quot;, x);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables5" class="admonition note">
<summary class="admonition-title">
<p>variables5</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables5"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables5.rs
// Execute `rustlings hint variables5` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

fn main() {
    let number = &quot;T-H-R-E-E&quot;; // don't change this line
    println!(&quot;Spell a Number : {}&quot;, number);
    number = 3; // don't rename this variable
    println!(&quot;Number plus two is : {}&quot;, number + 2);
}
</code></pre></pre>
</div>
</details>
<details id="admonition-variables6" class="admonition note">
<summary class="admonition-title">
<p>variables6</p>
<p><a class="admonition-anchor-link" href="variables/variables.html#admonition-variables6"></a></p>
</summary>
<div>
<pre><pre class="playground"><code class="language-rust editable">// variables6.rs
// Execute `rustlings hint variables6` or use the `hint` watch subcommand for a hint.

// I AM NOT DONE

const NUMBER = 3;
fn main() {
    println!(&quot;Number {}&quot;, NUMBER);
}
</code></pre></pre>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <!--            <script src="https://utteranc.es/client.js"-->
            <!--                    repo="RustMagazine/rust_magazine_2022"-->
            <!--                    issue-term="title"-->
            <!--                    theme="github-light"-->
            <!--                    crossorigin="anonymous"-->
            <!--                    async></script>-->

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->


                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">

    </nav>

</div>



    <script type="text/javascript">
        window.playground_line_numbers = true;
    </script>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>

    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/ferris/ferris.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid.min.js"></script>
    <script type="text/javascript" src="assets/mermaid/mermaid-init.js"></script>
    <script type="text/javascript" src="assets/smart-anchor.js"></script>
    <script type="text/javascript" src="assets/pagetoc/sidebar.js"></script>

        <script type="text/javascript">
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>
</body>
</html>
